{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>             A data analysis framework  for exoplanet detection         </p> Documentation"},{"location":"docs/","title":"Welcome","text":"<p>kima is the name of a really good drink produced in Azores  And now, it's also a package for the analysis of radial velocity (RV) data.</p> <p> </p> <p>In brief, kima fits Keplerian curves to a set of RV measurements, using the Diffusive Nested Sampling algorithm<sup>1</sup> to sample the posterior distribution for the model parameters. Additionally, the code can calculate the fully marginalized likelihood (or evidence, \\(Z\\)) of a model with a given number of Keplerians and also infer the number (\\(N_p\\)) of Keplerian signals detected in a given dataset. In this case, \\(N_p\\) is a free parameter and its posterior distribution is estimated<sup>2</sup><sup>, </sup><sup>3</sup>.</p> <p>The code is under active development at  this  GitHub repository. This page hosts the documentation, examples, and detailed APIs.</p> <p>If you use kima in your work or research, we kindly ask that you include the following citation<sup>4</sup></p> <pre><code>Faria et al., (2018). kima: Exoplanet detection in radial velocities.\nJournal of Open Source Software, 3(26), 487\n</code></pre> <p>Feel free to use the following BibTeX entry, or see the ADS entry 2018JOSS....3..487F.</p> <pre><code>@article{kima,\n      title = {kima: Exoplanet detection in radial velocities},\n      author = {Faria, J. P. and Santos, N. C. and Figueira, P. and Brewer, B. J.},\n      journal = {Journal of Open Source Software},\n      issn = {2475-9066},\n      number = {26},\n      volume = {3},\n      pages = {487},\n      date = {2018-06-19},\n      year = {2018},\n      month = {6},\n      day = {19},\n      publisher = {The Open Journal},\n      doi = {10.21105/joss.00487},\n      url = {http://dx.doi.org/10.21105/joss.00487},\n}\n</code></pre>"},{"location":"docs/#references","title":"References","text":"<ol> <li> <p>Brewer, B.J., P\u00e1rtay, L.B. &amp; Cs\u00e1nyi, G. Diffusive Nested Sampling. Stat    Comput 21, 649\u2013656 (2011) arXiv,   DOI \u21a9</p> </li> <li> <p>Brewer, B.J., Inference for Trans-dimensional Bayesian Models with   Diffusive Nested Sampling (2015) arXiv \u21a9</p> </li> <li> <p>Brewer, B.J. and Donovan, C.P., Fast Bayesian inference for exoplanet   discovery in radial velocity data, MNRAS 448, 4, 3206\u20133214 (2015) arXiv,   DOI \u21a9</p> </li> <li> <p>Faria et al., kima: Exoplanet detection in radial velocities. Journal of   Open Source Software, 3(26), 487 (2018) arXiv,   DOI \u21a9</p> </li> </ol>"},{"location":"docs/default_priors/","title":"Default priors","text":"<p>In the tables below, the following abbreviations are used:</p> <ul> <li>\\(\\Delta t\\) is the timespan of the data</li> <li>\\(\\Delta v\\) is the span of the RVs</li> <li>\\(\\Delta {\\rm FWHM}\\) is the span of the FWHM</li> <li>\\(\\mathcal{O}(x)\\) is order of magnitude of \\(x\\)</li> </ul> RVmodelGPmodelRVFWHMmodel name meaning default prior <code>beta_prior</code> Gaussian(0, 1) activity indicator coefficients <code>offsets_prior</code> Uniform(-\\(\\Delta v\\), \\(\\Delta v\\)) between-instrument offsets <code>stellar_jitter_prior</code> Fixed(0) stellar jitter <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>nu_prior</code> LogUniform(2, 1000) degrees of freedom of Student-t likelihood name meaning default prior <code>beta_prior</code> Gaussian(0, 1) activity indicator coefficients <code>offsets_prior</code> Uniform(-\\(\\Delta v\\), \\(\\Delta v\\)) between-instrument offsets <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>eta1_prior</code> LogUniform(0.1, \\(\\Delta v_{\\rm max}\\)) GP \"amplitude\" <code>eta2_prior</code> LogUniform(1, \\(\\Delta t\\)) GP correlation timescale <code>eta3_prior</code> Uniform(10, 40) GP period <code>eta4_prior</code> Uniform(0.2, 5.0) recurrence timescale name meaning default prior <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>eta1_prior</code> LogUniform(0.1, \\(\\Delta v_{\\rm max}\\)) GP \"amplitude\" <code>eta2_prior</code> LogUniform(1, \\(\\Delta t\\)) GP correlation timescale <code>eta3_prior</code> Uniform(10, 40) GP period <code>eta4_prior</code> Uniform(0.2, 5.0) recurrence timescale <code>Cfwhm_prior</code> Uniform(FWHM\\(_{\\rm min}\\), FWHM\\(_{\\rm max}\\)) \"systemic\" FWHM <code>Jfwhm_prior</code> complicated jitter in FWHM <code>slope_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t})\\)) <code>quadr_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t^2})\\)) <code>cubic_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t^3})\\)) <code>eta1_fwhm_prior</code> LogUniform(0.1, \\(\\Delta {\\rm FWHM}\\)) <code>eta2_fwhm_prior</code> LogUniform(1, \\(\\Delta t\\)) <code>eta3_fwhm_prior</code> Uniform(10, 40) <code>eta4_fwhm_prior</code> Uniform(0.2, 5.0)"},{"location":"docs/getting-started/","title":"Getting started","text":""},{"location":"docs/getting-started/#data-models-and-results","title":"Data, models, and results","text":"<p>To get started, read in a dataset and choose one of the available models:</p> <pre><code>import kima\nfrom kima import RVData, RVmodel\n\ndata = RVData('my_dataset')\n\nmodel = RVmodel(fix=True, npmax=1, data=data)\n</code></pre> <p>and then run the model</p> <pre><code>kima.run(model, steps=1000)\n</code></pre> <p>The resulting posteriors can be loaded and analysed easily (more information here)</p> <pre><code>res = kima.load_results(model)\nres.plot_posterior_periods()\n</code></pre>"},{"location":"docs/getting-started/#running-the-examples","title":"Running the examples","text":"<p>kima comes packed with ready-to-run examples.  All of them are described to some length here.</p>"},{"location":"docs/getting-started/#finding-51-peg-b","title":"Finding 51 Peg b","text":"<p>One of the examples involves the detection of 51 Peg b in Keck/HIRES data. Running it is as simple as </p> <pre><code>from kima.examples import _51Peg\n\nmodel, res = _51Peg(run=True, load=True) #(1)\n</code></pre> <ol> <li>This will run kima for 5000 steps, taking a few seconds.</li> </ol> <p>and the results object provides a number of useful plots </p> <pre><code>res.plot_posterior_np() #(1)\n\nres.plot_posterior_periods() #(2)\n\np = res.maximum_likelihood_sample() #(3)\nres.phase_plot(p) #(4)\n</code></pre> <ol> <li>shows the posterior for the number of planets</li> <li>shows the posterior for the orbital period, with a clear peak at 4.23 days</li> <li>select the sample with the maximum likelihood value</li> <li>plot the maximum likelihood solution in phase</li> </ol>"},{"location":"docs/installation/","title":"Installation","text":""},{"location":"docs/installation/#from-pypi","title":"From PyPI","text":"<p>kima can easily be installed using pip:</p> <pre><code>pip install kima\n</code></pre> <p></p> <p>Installation is tested on Linux, Windows, and MacOS regularly. If the following badge is green, things should be working  (even if it's red, go ahead and try it anyway )</p> <p></p> <p>Danger</p> <p>In some cases, the installation process will compile the C++ code using CMake, which requires at least CMake v3.17. It should be easy to install (or update) on most platforms. See this official page for more information.</p>"},{"location":"docs/installation/#from-the-repository","title":"From the repository","text":"<p>Alternatively, you can also clone the  GitHub repository</p> <pre><code>git clone https://github.com/kima-org/kima.git\n</code></pre> <p>and install the package locally</p> <pre><code>cd kima\npip install -e .\n</code></pre> <p>If the installation fails, open an issue here or comment below.</p>"},{"location":"docs/models/","title":"Models","text":""},{"location":"docs/models/#types-of-models","title":"Types of models","text":"<p>kima currently implements dedicated models for different analyses of a given dataset. The models share a common organization, but each has its own parameters, priors, and settings.</p> <ul> <li> <p>RVmodel   Models the RVs with a sum-of-Keplerians</p> </li> <li> <p>GPmodel   Models the RVs with a sum-of-Keplerians plus a correlated noise component   given by a Gaussian process</p> </li> <li> <p>RVFWHMmodel   Models the RVs together with the FWHM as an activity indicator, including a   Gaussian process for the activity signal</p> </li> <li> <p>BINARIESmodel   This includes tidal and relativistic effects as well as apsidal precession of   the binary\u2019s orbit (applicable for circumbinary planets), and can also fit    double-lined binary data. More details are available in   Baycroft et al. (2023).</p> </li> <li> <p>TRANSITmodel (coming soon)</p> </li> <li>GAIAmodel (comming soon)</li> </ul> <p>To use a given model, just instantiate an object of the respective class providing the necessary options and a dataset</p> kima_setup.py<pre><code>from kima import RVmodel, GPmodel\n\ndata = ...\n\nmodel = RVmodel(fix=True, npmax=1, data=data)\n# or\nmodel = GPmodel(fix=True, npmax=1, data=data)\n</code></pre> Info <p>The arguments to the models can be provided as positional arguments, as in <pre><code>RVmodel(True, 1, data)\n</code></pre> but this is discouraged for being less readable.  Note, however, that there are not default values for these arguments,  as the keyword syntax could lead to believe.</p> <p>Each model has its own parameters and particular settings,  which are described in detail in the API page. Below we include a more mathematical description of each model.</p> RVmodelGPmodel <p>This is the most basic model, but already allows for an in-depth analysis  of an RV dataset. In terms of general settings, we can define</p> <pre><code>model = RVmodel(fix=True, npmax=1, data=data) # (4)\n\nmodel.trend = False / True\nmodel.degree = 0 / 1 / 2 / 3 # (1)\n\nmodel.set_known_object(1) # (2)\n\nmodel.studentt = False / True # (3)\n</code></pre> <ol> <li> <p>sets up a long-term trend in the RVs, of a given degree. This is a  linear trend for <code>degree=1</code>, a quadratic for <code>degree=2</code>, and a cubic for  <code>degree=3</code>. Higher degree trends are not implemented.</p> </li> <li> <p>In known object (KO!) mode, kima considers some Keplerians as part  of a \"background\" model (see below). This can be useful when modelling  transiting planets or simply planets with better-known orbital parameters. </p> </li> <li> <p>Whether to use a Student-t distribution as the likelihood, instead of a Gaussian. If this is set to <code>True</code>, the degrees of freedom of the Student-t distribution can be estimated from the data. This is sometimes useful when the RV data is suspected to contain (a few) strong outliers.  See the example for more information.</p> </li> <li> <p>See below for more information</p> </li> </ol> <p>This model considers a Gaussian process as a surrogate model for the  stellar activity signal present in the RVs. It uses the now standard  quasi-periodic kernel<sup>1</sup> with four hyper-parameters:</p> \\[ k(t_i, t_j) = \\eta_1^2                  \\exp\\left[-\\frac{(t_i - t_j)^2}{2\\eta_2^2}\\right]                  \\exp\\left[-\\frac{2\\sin^2\\left(\\frac{\\pi (t_i - t_j)}{\\eta_3}\\right)}{\\eta_4^2}\\right] \\] <p>Most of the same settings as for the <code>RVmodel</code> are available, except for <code>studentt</code> which doesn't apply in this case.</p> <pre><code>model = GPmodel(fix=True, npmax=1) # (3)\n\nmodel.trend = False / True\nmodel.degree = 0 / 1 / 2 / 3 # (1)\n\nmodel.set_known_object(1) # (2)      \n</code></pre> <ol> <li> <p>sets up a long-term trend in the RVs, of a given degree. This is a    linear trend for <code>degree=1</code>, a quadratic for <code>degree=2</code>, and a cubic for    <code>degree=3</code>. Higher degree trends are not implemented.</p> </li> <li> <p>In known object (KO!) mode, kima considers some Keplerians as part    of a \"background\" model (see below). This can be useful when modelling    transiting planets or simply planets with better-known orbital parameters. </p> </li> <li> <p>See below for more information</p> </li> </ol>"},{"location":"docs/models/#the-np-planets","title":"The Np planets","text":"<p>kima can model Keplerian functions, the RV signals induced by planets. But the distinguishing feature is that the code can actually model a number \\(N_p\\) of Keplerians, and this number does not need to be fixed a priori. In other words, kima estimates the joint posterior distribution for \\(N_p\\) and the orbital parameters of the planets \\(\\theta\\), given some data $ \\mathcal{D} $:</p> \\[ p(N_p, \\theta | \\mathcal{D} ) \\] <p>So \\(N_p\\) is actually a free parameter in the model (if we want). It is somewhat of a special parameter, in that it only takes discrete values, but it's otherwise similar to other parameters in the model. In particular, it needs a prior distribution as well.</p> <p>This part of the model can be set with the first two arguments to the constructors</p> <pre><code>model = RVmodel(fix=False, npmax=2, data=data)\n</code></pre> <p>which define whether or not \\(N_p\\) is fixed and its value or prior distribution</p> \\[     N_p      \\begin{cases}         = \\texttt{npmax},                       &amp; \\text{if}\\:\\texttt{fix}\\\\         \\sim \\mathcal{U}(0, \\texttt{npmax}),    &amp; \\text{otherwise}     \\end{cases} \\] check this out! <p> <pre><code>import marimo as mo\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <pre><code>Np = mo.ui.slider(0, 10)\nfix = mo.ui.checkbox()\nmo.md(f\"`model = RVmodel(fix=`{fix}`, npmax=`{Np}`, data=data)`\")\n</code></pre> <pre><code>pmf = np.zeros(11)\nfig, ax = plt.subplots(figsize=(6, 3))\nax.set(xticks=np.arange(11), yticks=[0, 1], \n       xlabel=\"$N_p$\", ylabel=\"prior\", ylim=[0, 1.1])\n\nif fix.value:\n    pmf[Np.value] = 1\nelse:\n    pmf[:Np.value+1] = 1 / (Np.value + 1)\n\nax.stem(np.arange(11), pmf)\nmo.mpl.interactive(fig)\n</code></pre> </p> <p>By default, each of the \\(N_p\\) planets has 5 orbital parameters</p> \\[ \\theta = { P, K, e, M_0, \\omega } \\] <p>corresponding to the orbital period, semi-amplitude, eccentricity, mean anomaly at the epoch, and argument of periastron.</p> <p>Some models include additional per-planet parameters: the BINARIESmodel considers a linear precession parameter \\(\\dot\\omega\\) and the BDmodel infers a mixture probability \\(\\lambda\\) for each planet.</p> <p>units</p> <ul> <li>\\(P\\) is in [days]</li> <li>\\(K\\) is in [m/s]</li> <li>\\(e\\) is unitless</li> <li>\\(M_0\\) and \\(\u03c9\\) are in radians</li> </ul> <p>By default, the epoch is set to the middle of the observed times (\\(t_{\\rm min} + \\Delta t / 2\\)), but it can be changed by setting the corresponding attribute of the data:</p> <pre><code>data.M0_epoch = ...\n</code></pre>"},{"location":"docs/models/#the-background-model","title":"The \"background\" model","text":"<p>Besides the \\(N_p\\) planets, kima models the RV observations as follows</p> <ul> <li>by default</li> </ul> \\[ v_i \\sim \\mathcal{N} \\left( v_{sys} \\,,\\: j^2+\\sigma_i^2 \\right) \\] <ul> <li>if using a Student-t likelihood</li> </ul> \\[ v_i \\sim \\mathcal{T} \\left( v_{sys} \\,,\\: j^2+\\sigma_i^2, \\nu \\right) \\] <ul> <li>if using a Gaussian process</li> </ul> \\[ v \\sim \\mathcal{GP} \\left( \\boldsymbol{\\mu} = v_{sys} \\,,\\: \\boldsymbol{\\Sigma} = {\\bf K} + (j^2+\\sigma_i^2)\\,\\delta_{ij}\\,{\\bf I} \\right) \\] <p>where \\(j\\) is a jitter parameter that represents additional white noise variations not accounted for by the individual uncertainties. </p> <p>When considering a long-term trend (by setting <code>trend=True</code>), instead of a constant systemic velocity, we have</p> \\[ \\begin{aligned} v_{sys} \\rightarrow v_{sys}    &amp; + \\text{slope} \\times (t-t_m) \\qquad      \\text{if} \\: \\texttt{degree} \\ge 1\\\\   &amp; + \\text{quadr} \\times (t-t_m)^2 \\quad\\,   \\text{if} \\: \\texttt{degree} \\ge 2\\\\   &amp; + \\text{cubic} \\times (t-t_m)^3 \\quad\\:\\: \\text{if} \\: \\texttt{degree} = 3 \\end{aligned} \\] <p>where \\(t_m\\) is the mean of the times and slope, quadr, and cubic are free parameters. See the example for more information.</p> <p>When using data from multiple instruments, kima adds RV offsets between pairs of instruments as well as individual jitter parameters per instrument.</p>"},{"location":"docs/models/#known-object-mode","title":"Known object mode","text":"<p>As described below, the priors for the orbital parameters of the \\(N_p\\) planets are all the same. </p> <p>To go around this limitation, we can add known objects to the background model, which are simply Keplerians for which we define individual priors. Each of these Keplerians has the same 5 orbital parameters \\({P, K, e, M_0, \\omega}\\), in the same units. </p> <p>Note</p> <p>The number of known objects is defined by the user and is always fixed, unlike \\(N_p\\).</p> <p>Most models can accomodate known objects which can be added to the model with the following code</p> <pre><code>model.set_known_object(1)\n\nmodel.KO_Pprior = [kima.distributions...]\nmodel.KO_Kprior = [...]\nmodel.KO_eprior = [...]\nmodel.KO_phiprior = [...]\nmodel.KO_wprior = [...]\n</code></pre>"},{"location":"docs/models/#prior-distributions","title":"Prior distributions","text":"<p>As in any Bayesian analysis, kima needs a set of priors for the model parameters. If we don't explicitly set the priors, default ones will be  used and the model will run. But sometimes we will want to set custom priors for some parameters.</p> <p>To change specific priors, we just need to re-assign some attributes of the models, using the probability distributions defined in kima.distributions. Admittedly, some of these attributes might have rather undescriptive names,  but they are still documented individually.</p> <p>For example, let's re-define the priors for the jitter and for the orbital periods of the \\(N_p\\) planets</p> <pre><code>from kima.distributions import Uniform, Gaussian\n\nmodel = RVmodel(...)\n\nmodel.Jprior = Uniform(1, 20)  # (1)\n\nmodel.conditional.Pprior = Gaussian(15, 0.1)\n</code></pre> <ol> <li> Note that this is a uniform distribution from 1 m/s to 20 m/s, unlike the <code>scipy.stats.uniform</code> distribution which would have support [1, 21] !</li> </ol> <p>Warning</p> <p>While it might seem counter-intuitive at first, the priors for the orbital parameters are the same for all the \\(N_p\\) planets. This is intentional! But if this is not what you want, consider using the known object feature.</p> <p><code>conditional</code> priors</p> <p>The priors for the orbital parameters of the \\(N_p\\) Keplerians are included in the <code>model.conditional</code> object because these priors are  conditional on having those Keplerians.</p> <p>In the example above, we specify the prior distribution and its parameters. The list of currently implemented distributions is described here. If you need a distribution that is not yet implemented, consider opening an issue.</p>"},{"location":"docs/models/#default-priors","title":"Default priors","text":"<p>Below is the list of default priors which are used if not explicitly re-defined.</p> <p>In the tables below, the following abbreviations are used:</p> <ul> <li>\\(\\Delta t\\) is the timespan of the data</li> <li>\\(\\Delta v\\) is the span of the RVs</li> <li>\\(\\Delta {\\rm FWHM}\\) is the span of the FWHM</li> <li>\\(\\mathcal{O}(x)\\) is order of magnitude of \\(x\\)</li> </ul> RVmodelGPmodelRVFWHMmodel name meaning default prior <code>beta_prior</code> Gaussian(0, 1) activity indicator coefficients <code>offsets_prior</code> Uniform(-\\(\\Delta v\\), \\(\\Delta v\\)) between-instrument offsets <code>stellar_jitter_prior</code> Fixed(0) stellar jitter <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>nu_prior</code> LogUniform(2, 1000) degrees of freedom of Student-t likelihood name meaning default prior <code>beta_prior</code> Gaussian(0, 1) activity indicator coefficients <code>offsets_prior</code> Uniform(-\\(\\Delta v\\), \\(\\Delta v\\)) between-instrument offsets <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>eta1_prior</code> LogUniform(0.1, \\(\\Delta v_{\\rm max}\\)) GP \"amplitude\" <code>eta2_prior</code> LogUniform(1, \\(\\Delta t\\)) GP correlation timescale <code>eta3_prior</code> Uniform(10, 40) GP period <code>eta4_prior</code> Uniform(0.2, 5.0) recurrence timescale name meaning default prior <code>slope_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t} \\right)\\)) slope of linear trend <code>quadr_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^2} \\right)\\)) coefficient of quadratic trend <code>cubic_prior</code> Gaussian(0, \\(\\mathcal{O} \\left(\\frac{ \\Delta v }{ \\Delta t^3} \\right)\\)) coefficient of cubic trend <code>eta1_prior</code> LogUniform(0.1, \\(\\Delta v_{\\rm max}\\)) GP \"amplitude\" <code>eta2_prior</code> LogUniform(1, \\(\\Delta t\\)) GP correlation timescale <code>eta3_prior</code> Uniform(10, 40) GP period <code>eta4_prior</code> Uniform(0.2, 5.0) recurrence timescale <code>Cfwhm_prior</code> Uniform(FWHM\\(_{\\rm min}\\), FWHM\\(_{\\rm max}\\)) \"systemic\" FWHM <code>Jfwhm_prior</code> complicated jitter in FWHM <code>slope_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t})\\)) <code>quadr_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t^2})\\)) <code>cubic_fwhm_prior</code> Gaussian(0, \\(\\mathcal{O} (\\frac{\\Delta {\\rm FWHM}}{\\Delta t^3})\\)) <code>eta1_fwhm_prior</code> LogUniform(0.1, \\(\\Delta {\\rm FWHM}\\)) <code>eta2_fwhm_prior</code> LogUniform(1, \\(\\Delta t\\)) <code>eta3_fwhm_prior</code> Uniform(10, 40) <code>eta4_fwhm_prior</code> Uniform(0.2, 5.0) <p>And for the orbital parameters</p> orbital parameters <ul> <li> <p>orbital period(s), <code>conditional.Pprior</code>   LogUniform(1, \\(\\Delta t\\))</p> </li> <li> <p>semi-amplitude(s), <code>conditional.Kprior</code>   Uniform(0, \\(\\Delta v\\))</p> </li> <li> <p>orbital eccentricity(ies), <code>conditional.eprior</code>   Uniform(0, 1)</p> </li> <li> <p>mean anomaly at the epoch, <code>conditional.phiprior</code>   Uniform(0, 2\\(\\pi\\))</p> </li> <li> <p>argument of pericenter, <code>conditional.wprior</code>   Uniform(0, 2\\(\\pi\\))</p> </li> </ul> <p>How many parameters?</p> <p>The number of free parameters can change substantially depending on the model,  the different settings, and the specific parameter priors  (which can be Fixed, for example). In essence, the number of free parameters is usually not a very useful quantity by itself.</p>"},{"location":"docs/models/#references","title":"References","text":"<ol> <li> <p>Rasmussen, C.E. and Williams, C.K.I. (2006) Gaussian processes for machine learning.    The MIT Press, ISBN 0-262-18253-X link,    PDF \u21a9</p> </li> </ol>"},{"location":"docs/troubleshooting/","title":"Troubleshooting","text":""},{"location":"docs/troubleshooting/#problems-with-installation","title":"Problems with installation","text":"<ul> <li> <p>We've pre-packaged kima so that it can be easily installed with <code>pip</code>. If   the installation fails on your machine, it could be because you're using an   old version of a C++ compiler. Try running <code>g++ --version</code> to check the   version (or the appropriate command for the compiler you're using).</p> </li> <li> <p>If you can't get it to work, open an issue    on GitHub and let's try to fix it.</p> </li> </ul>"},{"location":"docs/troubleshooting/#other-issues","title":"Other issues","text":"<ul> <li>Segmentation faults   If you run into a segmentation fault before kima even prints anything to   the terminal, it might be due to an issue reading the data files. Check if the   first three columns of the file(s) are numbers and not strings.</li> </ul>"},{"location":"docs/troubleshooting/#i-think-something-is-wrong","title":"I think something is wrong...","text":"<p>Let us know in the issues if you think there is a problem or if something doesn't work as expected.</p>"},{"location":"docs/troubleshooting/#i-could-do-with-some-help-analysing-rvs","title":"I could do with some help analysing RVs","text":"<p>kima is free software and provided as is within the terms of the LICENSE. However, we are available to help if we can! The issue tracker is a good place to ask questions about kima or the analysis of RV data, but feel free to contact us by email if needed.</p>"},{"location":"docs/API/","title":"API","text":"<p>The two pages below describe the public API of kima and <code>pykima</code> separately.</p> <ul> <li> <p>kima:   the main package </p> </li> <li> <p>pykima:   an helper sub-package to analyse results</p> </li> </ul>"},{"location":"docs/API/kima/","title":"API documentation for <code>kima</code>","text":""},{"location":"docs/API/kima/#data","title":"Data","text":"<p>Most analyses will start by using the <code>RVData</code> class to load data from a set of files or arrays</p>"},{"location":"docs/API/kima/#example","title":"Example:","text":"<pre><code>from kima import RVData\n\ndata = RVData('filename.txt', skip=1) #(1)!\n\ndata.plot() #(2)!\n</code></pre> <ol> <li>With <code>skip=1</code>, the first line of the file will be ignored.</li> <li>A very simple plot of the dataset.</li> </ol> <code>kima.RVData</code> API <p>Load and store RV data</p> <p>init(self, filenames: collections.abc.Sequence[str], units: str = 'ms', skip: int = 0, max_rows: int = 0, delimiter: str = ' \\t,', indicators: collections.abc.Sequence[str] = [], double_lined: bool = False) -&gt; None init(self, filename: str, units: str = 'ms', skip: int = 0, max_rows: int = 0, multi: bool = False, delimiter: str = ' \\t,', indicators: collections.abc.Sequence[str] = [], double_lined: bool = False) -&gt; None init(self, t: collections.abc.Sequence[float], y: collections.abc.Sequence[float], sig: collections.abc.Sequence[float], units: str = 'ms', instrument: str = '') -&gt; None init(self, t: collections.abc.Sequence[collections.abc.Sequence[float]], y: collections.abc.Sequence[collections.abc.Sequence[float]], sig: collections.abc.Sequence[collections.abc.Sequence[float]], units: str = 'ms', instruments: collections.abc.Sequence[str] = []) -&gt; None</p> <p>Overloaded function.</p> <ol> <li><code>__init__(self, filenames: collections.abc.Sequence[str], units: str = 'ms', skip: int = 0, max_rows: int = 0, delimiter: str = ' \\t,', indicators: collections.abc.Sequence[str] = [], double_lined: bool = False) -&gt; None</code></li> </ol> <p>Load RV data from a list of files</p> <ol> <li><code>__init__(self, filename: str, units: str = 'ms', skip: int = 0, max_rows: int = 0, multi: bool = False, delimiter: str = ' \\t,', indicators: collections.abc.Sequence[str] = [], double_lined: bool = False) -&gt; None</code></li> </ol> <p>Load RV data from a file</p> <ol> <li><code>__init__(self, t: collections.abc.Sequence[float], y: collections.abc.Sequence[float], sig: collections.abc.Sequence[float], units: str = 'ms', instrument: str = '') -&gt; None</code></li> </ol> <p>Load RV data from arrays</p> <ol> <li><code>__init__(self, t: collections.abc.Sequence[collections.abc.Sequence[float]], y: collections.abc.Sequence[collections.abc.Sequence[float]], sig: collections.abc.Sequence[collections.abc.Sequence[float]], units: str = 'ms', instruments: collections.abc.Sequence[str] = []) -&gt; None</code></li> </ol> <p>Load RV data from arrays, for multiple instruments</p>"},{"location":"docs/API/kima/#kima.Data.RVData.M0_epoch","title":"<code>M0_epoch</code>  <code>property</code>","text":"<p>reference epoch for the mean anomaly</p>"},{"location":"docs/API/kima/#kima.Data.RVData.N","title":"<code>N</code>  <code>property</code>","text":"<p>Total number of observations</p>"},{"location":"docs/API/kima/#kima.Data.RVData.actind","title":"<code>actind</code>  <code>property</code>","text":"<p>Activity indicators</p>"},{"location":"docs/API/kima/#kima.Data.RVData.datafile","title":"<code>datafile</code>  <code>property</code>","text":"<p>The file name</p>"},{"location":"docs/API/kima/#kima.Data.RVData.datafiles","title":"<code>datafiles</code>  <code>property</code>","text":"<p>The list of file names</p>"},{"location":"docs/API/kima/#kima.Data.RVData.double_lined","title":"<code>double_lined</code>  <code>property</code>","text":"<p>if the data is for a double-lined binary</p>"},{"location":"docs/API/kima/#kima.Data.RVData.indicator_names","title":"<code>indicator_names</code>  <code>property</code>","text":"<p>names of activity indicators</p>"},{"location":"docs/API/kima/#kima.Data.RVData.instrument","title":"<code>instrument</code>  <code>property</code>","text":"<p>instrument name</p>"},{"location":"docs/API/kima/#kima.Data.RVData.instruments","title":"<code>instruments</code>  <code>property</code>","text":"<p>instrument names</p>"},{"location":"docs/API/kima/#kima.Data.RVData.multi","title":"<code>multi</code>  <code>property</code>","text":"<p>Data comes from multiple instruments</p>"},{"location":"docs/API/kima/#kima.Data.RVData.normalized_actind","title":"<code>normalized_actind</code>  <code>property</code>","text":"<p>Activity indicators normalized to [0,1]</p>"},{"location":"docs/API/kima/#kima.Data.RVData.obsi","title":"<code>obsi</code>  <code>property</code>","text":"<p>The instrument identifier</p>"},{"location":"docs/API/kima/#kima.Data.RVData.sig","title":"<code>sig</code>  <code>property</code>","text":"<p>The observed RV uncertainties</p>"},{"location":"docs/API/kima/#kima.Data.RVData.skip","title":"<code>skip</code>  <code>property</code>","text":"<p>Lines skipped when reading data</p>"},{"location":"docs/API/kima/#kima.Data.RVData.t","title":"<code>t</code>  <code>property</code>","text":"<p>The times of observations</p>"},{"location":"docs/API/kima/#kima.Data.RVData.units","title":"<code>units</code>  <code>property</code>","text":"<p>Units of the RVs and uncertainties</p>"},{"location":"docs/API/kima/#kima.Data.RVData.y","title":"<code>y</code>  <code>property</code>","text":"<p>The observed radial velocities</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_max","title":"<code>get_RV_max()</code>  <code>method descriptor</code>","text":"<p>get_RV_max(self) -&gt; float</p> <p>Get the maximum RV</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_mean","title":"<code>get_RV_mean()</code>  <code>method descriptor</code>","text":"<p>get_RV_mean(self) -&gt; float</p> <p>Get the mean RV</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_min","title":"<code>get_RV_min()</code>  <code>method descriptor</code>","text":"<p>get_RV_min(self) -&gt; float</p> <p>Get the minimum RV</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_span","title":"<code>get_RV_span()</code>  <code>method descriptor</code>","text":"<p>get_RV_span(self) -&gt; float</p> <p>Get the RV span</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_std","title":"<code>get_RV_std()</code>  <code>method descriptor</code>","text":"<p>get_RV_std(self) -&gt; float</p> <p>Get the standard deviation of RVs</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_RV_var","title":"<code>get_RV_var()</code>  <code>method descriptor</code>","text":"<p>get_RV_var(self) -&gt; float</p> <p>Get the variance of RVs</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_max_RV_span","title":"<code>get_max_RV_span()</code>  <code>method descriptor</code>","text":"<p>get_max_RV_span(self) -&gt; float</p> <p>Get the maximum RV span of individual instruments</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_t_max","title":"<code>get_t_max()</code>  <code>method descriptor</code>","text":"<p>get_t_max(self) -&gt; float</p> <p>Get the maximum time</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_t_middle","title":"<code>get_t_middle()</code>  <code>method descriptor</code>","text":"<p>get_t_middle(self) -&gt; float</p> <p>Get the middle time</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_t_min","title":"<code>get_t_min()</code>  <code>method descriptor</code>","text":"<p>get_t_min(self) -&gt; float</p> <p>Get the minimum time</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_timespan","title":"<code>get_timespan()</code>  <code>method descriptor</code>","text":"<p>get_timespan(self) -&gt; float</p> <p>Get the timespan</p>"},{"location":"docs/API/kima/#kima.Data.RVData.get_trend_magnitude","title":"<code>get_trend_magnitude()</code>  <code>method descriptor</code>","text":"<p>get_trend_magnitude(self, arg0: int, arg1: int, /) -&gt; int</p> <p>Order of magnitude of trend coefficient (of degree) given the data</p>"},{"location":"docs/API/kima/#kima.Data.RVData.load","title":"<code>load()</code>  <code>method descriptor</code>","text":"<p>load(self, filename: str, units: str, skip: int, max_rows: int, delimiter: str, indicators: collections.abc.Sequence[str]) -&gt; None</p> <p>Load RV data from a tab/space separated file with columns <pre><code>time  vrad  error  quant  error\n...   ...   ...    ...    ...\n</code></pre> Args:     filename (str): the name of the file     untis (str): units of the RVs and errors, either \"kms\" or \"ms\"     skip (int): number of lines to skip in the beginning of the file (default = 2)     indicators (list[str]): nodoc</p>"},{"location":"docs/API/kima/#kima.Data.RVData.plot","title":"<code>plot(data, **kwargs)</code>","text":"<p>Simple plot of RV data</p>"},{"location":"docs/API/kima/#kima.Data.RVData.topslope","title":"<code>topslope()</code>  <code>method descriptor</code>","text":"<p>topslope(self) -&gt; float</p> <p>Get the maximum slope allowed by the data</p>"},{"location":"docs/API/kima/#models","title":"Models","text":"<p>We can then create one of the several models currently implemented</p>"},{"location":"docs/API/kima/#example_1","title":"Example:","text":"<pre><code>from kima import RVmodel\n\nmodel = RVmodel(fix=False, npmax=2, data=data)\n</code></pre> <code>kima.RVmodel</code> API <code>kima.GPmodel</code> API <code>kima.RVFWHMmodel</code> API <code>kima.BINARIESmodel</code> API"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel","title":"<code>RVmodel()</code>","text":"<p>init(self, fix: bool, npmax: int, data: kima.Data.RVData) -&gt; None</p> <p>Implements a sum-of-Keplerians model where the number of Keplerians can be free.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool</code> <p>whether the number of Keplerians should be fixed</p> required <code>npmax</code> <code>int</code> <p>maximum number of Keplerians</p> required <code>data</code> <code>RVData</code> <p>the RV data</p> required"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.Cprior","title":"<code>Cprior</code>  <code>property</code>","text":"<p>Prior for the systemic velocity</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.Jprior","title":"<code>Jprior</code>  <code>property</code>","text":"<p>Prior for the extra white noise (jitter)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.KO_Kprior","title":"<code>KO_Kprior</code>  <code>property</code>","text":"<p>Prior for KO semi-amplitude</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.KO_Pprior","title":"<code>KO_Pprior</code>  <code>property</code>","text":"<p>Prior for KO orbital period</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.KO_eprior","title":"<code>KO_eprior</code>  <code>property</code>","text":"<p>Prior for KO eccentricity</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.KO_phiprior","title":"<code>KO_phiprior</code>  <code>property</code>","text":"<p>Prior for KO mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.KO_wprior","title":"<code>KO_wprior</code>  <code>property</code>","text":"<p>Prior for KO argument of periastron</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.TR_Kprior","title":"<code>TR_Kprior</code>  <code>property</code>","text":"<p>Prior for TR semi-amplitude</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.TR_Pprior","title":"<code>TR_Pprior</code>  <code>property</code>","text":"<p>Prior for TR orbital period</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.TR_Tcprior","title":"<code>TR_Tcprior</code>  <code>property</code>","text":"<p>Prior for TR mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.TR_eprior","title":"<code>TR_eprior</code>  <code>property</code>","text":"<p>Prior for TR eccentricity</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.TR_wprior","title":"<code>TR_wprior</code>  <code>property</code>","text":"<p>Prior for TR argument of periastron</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.beta_prior","title":"<code>beta_prior</code>  <code>property</code>","text":"<p>(Common) prior for the activity indicator coefficients</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.conditional","title":"<code>conditional</code>  <code>property</code>","text":"<p>(self) -&gt; kima.RVmodel.KeplerianConditionalPrior</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.cubic_prior","title":"<code>cubic_prior</code>  <code>property</code>","text":"<p>Prior for the cubic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.data","title":"<code>data</code>  <code>property</code>","text":"<p>the data</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>degree of the polynomial trend</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.directory","title":"<code>directory</code>  <code>property</code>","text":"<p>directory where the model ran</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.enforce_stability","title":"<code>enforce_stability</code>  <code>property</code>","text":"<p>whether to enforce AMD-stability</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.fix","title":"<code>fix</code>  <code>property</code>","text":"<p>whether the number of Keplerians is fixed</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.indicator_correlations","title":"<code>indicator_correlations</code>  <code>property</code>","text":"<p>include in the model linear correlations with indicators</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.individual_offset_prior","title":"<code>individual_offset_prior</code>  <code>property</code>","text":"<p>Common prior for the between-instrument offsets</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.jitter_propto_indicator","title":"<code>jitter_propto_indicator</code>  <code>property</code>","text":"<p>docs</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.jitter_propto_indicator_index","title":"<code>jitter_propto_indicator_index</code>  <code>property</code>","text":"<p>docs</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.known_object","title":"<code>known_object</code>  <code>property</code>","text":"<p>whether the model includes (better) known extra Keplerian curve(s)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.n_known_object","title":"<code>n_known_object</code>  <code>property</code>","text":"<p>how many known objects</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.n_transiting_planet","title":"<code>n_transiting_planet</code>  <code>property</code>","text":"<p>how many transiting planets</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.npmax","title":"<code>npmax</code>  <code>property</code>","text":"<p>maximum number of Keplerians</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.nu_prior","title":"<code>nu_prior</code>  <code>property</code>","text":"<p>Prior for the degrees of freedom of the Student-t likelihood</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.offsets_prior","title":"<code>offsets_prior</code>  <code>property</code>","text":"<p>Common prior for the between-instrument offsets</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.quadr_prior","title":"<code>quadr_prior</code>  <code>property</code>","text":"<p>Prior for the quadratic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.slope_prior","title":"<code>slope_prior</code>  <code>property</code>","text":"<p>Prior for the slope</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.star_mass","title":"<code>star_mass</code>  <code>property</code>","text":"<p>stellar mass [Msun]</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.stellar_jitter_prior","title":"<code>stellar_jitter_prior</code>  <code>property</code>","text":"<p>Prior for the stellar jitter (common to all instruments)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.studentt","title":"<code>studentt</code>  <code>property</code>","text":"<p>use a Student-t distribution for the likelihood (instead of Gaussian)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.transiting_planet","title":"<code>transiting_planet</code>  <code>property</code>","text":"<p>whether the model includes transiting planet(s)</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.trend","title":"<code>trend</code>  <code>property</code>","text":"<p>whether the model includes a polynomial trend</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.set_known_object","title":"<code>set_known_object()</code>  <code>method descriptor</code>","text":"<p>set_known_object(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.set_loguniform_prior_Np","title":"<code>set_loguniform_prior_Np()</code>  <code>method descriptor</code>","text":"<p>set_loguniform_prior_Np(self) -&gt; None</p>"},{"location":"docs/API/kima/#kima.RVmodel.RVmodel.set_transiting_planet","title":"<code>set_transiting_planet()</code>  <code>method descriptor</code>","text":"<p>set_transiting_planet(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel","title":"<code>GPmodel()</code>","text":"<p>init(self, fix: bool, npmax: int, data: kima.Data.RVData) -&gt; None</p> <p>Implements a model for the RVs with a sum-of-Keplerians plus a  correlated noise component given by a Gaussian process.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool</code> <p>whether the number of Keplerians should be fixed</p> required <code>npmax</code> <code>int</code> <p>maximum number of Keplerians</p> required <code>data</code> <code>RVData</code> <p>the RV data</p> required"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.Cprior","title":"<code>Cprior</code>  <code>property</code>","text":"<p>Prior for the systemic velocity</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.Jprior","title":"<code>Jprior</code>  <code>property</code>","text":"<p>Prior for the extra white noise (jitter)</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.KO_Kprior","title":"<code>KO_Kprior</code>  <code>property</code>","text":"<p>Prior for KO semi-amplitude</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.KO_Pprior","title":"<code>KO_Pprior</code>  <code>property</code>","text":"<p>Prior for KO orbital period</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.KO_eprior","title":"<code>KO_eprior</code>  <code>property</code>","text":"<p>Prior for KO eccentricity</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.KO_phiprior","title":"<code>KO_phiprior</code>  <code>property</code>","text":"<p>Prior for KO mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.KO_wprior","title":"<code>KO_wprior</code>  <code>property</code>","text":"<p>Prior for KO argument of periastron</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.Q_prior","title":"<code>Q_prior</code>  <code>property</code>","text":"<p>Prior for Q, the quality factor in SHO kernels</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.TR_Kprior","title":"<code>TR_Kprior</code>  <code>property</code>","text":"<p>Prior for TR semi-amplitude</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.TR_Pprior","title":"<code>TR_Pprior</code>  <code>property</code>","text":"<p>Prior for TR orbital period</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.TR_Tcprior","title":"<code>TR_Tcprior</code>  <code>property</code>","text":"<p>Prior for TR mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.TR_eprior","title":"<code>TR_eprior</code>  <code>property</code>","text":"<p>Prior for TR eccentricity</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.TR_wprior","title":"<code>TR_wprior</code>  <code>property</code>","text":"<p>Prior for TR argument of periastron</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.beta_prior","title":"<code>beta_prior</code>  <code>property</code>","text":"<p>(Common) prior for the activity indicator coefficients</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.conditional","title":"<code>conditional</code>  <code>property</code>","text":"<p>(self) -&gt; kima.RVmodel.KeplerianConditionalPrior</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.cubic_prior","title":"<code>cubic_prior</code>  <code>property</code>","text":"<p>Prior for the cubic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.data","title":"<code>data</code>  <code>property</code>","text":"<p>the data</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>degree of the polynomial trend</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.directory","title":"<code>directory</code>  <code>property</code>","text":"<p>directory where the model ran</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.enforce_stability","title":"<code>enforce_stability</code>  <code>property</code>","text":"<p>whether to enforce AMD-stability</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta1_prior","title":"<code>eta1_prior</code>  <code>property</code>","text":"<p>Prior for \u03b71, the GP 'amplitude'</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta2_prior","title":"<code>eta2_prior</code>  <code>property</code>","text":"<p>Prior for \u03b72, the GP correlation timescale</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta3_prior","title":"<code>eta3_prior</code>  <code>property</code>","text":"<p>Prior for \u03b73, the GP period</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta4_prior","title":"<code>eta4_prior</code>  <code>property</code>","text":"<p>Prior for \u03b74, the recurrence timescale or (inverse) harmonic complexity</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta5_prior","title":"<code>eta5_prior</code>  <code>property</code>","text":"<p>Prior for \u03b75</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta6_prior","title":"<code>eta6_prior</code>  <code>property</code>","text":"<p>Prior for \u03b76</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta7_prior","title":"<code>eta7_prior</code>  <code>property</code>","text":"<p>Prior for \u03b77</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.fix","title":"<code>fix</code>  <code>property</code>","text":"<p>whether the number of Keplerians is fixed</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.indicator_correlations","title":"<code>indicator_correlations</code>  <code>property</code>","text":"<p>include in the model linear correlations with indicators</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.individual_offset_prior","title":"<code>individual_offset_prior</code>  <code>property</code>","text":"<p>Common prior for the between-instrument offsets</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.kernel","title":"<code>kernel</code>  <code>property</code>","text":"<p>GP kernel to use</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.known_object","title":"<code>known_object</code>  <code>property</code>","text":"<p>whether the model includes (better) known extra Keplerian curve(s)</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.magnetic_cycle_kernel","title":"<code>magnetic_cycle_kernel</code>  <code>property</code>","text":"<p>whether to consider a (periodic) GP kernel for a magnetic cycle</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.n_known_object","title":"<code>n_known_object</code>  <code>property</code>","text":"<p>how many known objects</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.n_transiting_planet","title":"<code>n_transiting_planet</code>  <code>property</code>","text":"<p>how many transiting planets</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.npmax","title":"<code>npmax</code>  <code>property</code>","text":"<p>maximum number of Keplerians</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.offsets_prior","title":"<code>offsets_prior</code>  <code>property</code>","text":"<p>Common prior for the between-instrument offsets</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.quadr_prior","title":"<code>quadr_prior</code>  <code>property</code>","text":"<p>Prior for the quadratic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.slope_prior","title":"<code>slope_prior</code>  <code>property</code>","text":"<p>Prior for the slope</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.star_mass","title":"<code>star_mass</code>  <code>property</code>","text":"<p>stellar mass [Msun]</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.transiting_planet","title":"<code>transiting_planet</code>  <code>property</code>","text":"<p>whether the model includes transiting planet(s)</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.trend","title":"<code>trend</code>  <code>property</code>","text":"<p>whether the model includes a polynomial trend</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.eta2_larger_eta3","title":"<code>eta2_larger_eta3()</code>  <code>method descriptor</code>","text":"<p>eta2_larger_eta3(self, factor: float = 1.0) -&gt; None</p> <p>Constrain \u03b72 to be larger than factor * \u03b73</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.set_known_object","title":"<code>set_known_object()</code>  <code>method descriptor</code>","text":"<p>set_known_object(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.GPmodel.GPmodel.set_transiting_planet","title":"<code>set_transiting_planet()</code>  <code>method descriptor</code>","text":"<p>set_transiting_planet(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel","title":"<code>RVFWHMmodel()</code>","text":"<p>init(self, fix: bool, npmax: int, data: kima.Data.RVData) -&gt; None</p> <p>Implements a joint model for RVs and FWHM with a GP component for activity signals.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool</code> <p>whether the number of Keplerians should be fixed</p> required <code>npmax</code> <code>int</code> <p>maximum number of Keplerians</p> required <code>data</code> <code>RVData</code> <p>the RV data</p> required"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.Cfwhm_prior","title":"<code>Cfwhm_prior</code>  <code>property</code>","text":"<p>Prior for the 'systemic' FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.Cprior","title":"<code>Cprior</code>  <code>property</code>","text":"<p>Prior for the systemic velocity</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.Jfwhm_prior","title":"<code>Jfwhm_prior</code>  <code>property</code>","text":"<p>Prior for the extra white noise (jitter) in the FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.Jprior","title":"<code>Jprior</code>  <code>property</code>","text":"<p>Prior for the extra white noise (jitter)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.KO_Kprior","title":"<code>KO_Kprior</code>  <code>property</code>","text":"<p>Prior for KO semi-amplitude</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.KO_Pprior","title":"<code>KO_Pprior</code>  <code>property</code>","text":"<p>Prior for KO orbital period</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.KO_eprior","title":"<code>KO_eprior</code>  <code>property</code>","text":"<p>Prior for KO eccentricity</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.KO_phiprior","title":"<code>KO_phiprior</code>  <code>property</code>","text":"<p>Prior for KO mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.KO_wprior","title":"<code>KO_wprior</code>  <code>property</code>","text":"<p>Prior for KO argument of periastron</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.TR_Kprior","title":"<code>TR_Kprior</code>  <code>property</code>","text":"<p>Prior for TR semi-amplitude</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.TR_Pprior","title":"<code>TR_Pprior</code>  <code>property</code>","text":"<p>Prior for TR orbital period</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.TR_Tcprior","title":"<code>TR_Tcprior</code>  <code>property</code>","text":"<p>Prior for TR mean anomaly(ies)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.TR_eprior","title":"<code>TR_eprior</code>  <code>property</code>","text":"<p>Prior for TR eccentricity</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.TR_wprior","title":"<code>TR_wprior</code>  <code>property</code>","text":"<p>Prior for TR argument of periastron</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.conditional","title":"<code>conditional</code>  <code>property</code>","text":"<p>(self) -&gt; kima.RVmodel.KeplerianConditionalPrior</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.cubic_fwhm_prior","title":"<code>cubic_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for the cubic coefficient of the trend in the FWHM (in the FWHM)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.cubic_prior","title":"<code>cubic_prior</code>  <code>property</code>","text":"<p>Prior for the cubic coefficient of the trend (in the RVs)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.data","title":"<code>data</code>  <code>property</code>","text":"<p>the data</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>degree of the polynomial trend (in the RVs)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.degree_fwhm","title":"<code>degree_fwhm</code>  <code>property</code>","text":"<p>degree of the polynomial trend (in the FWHM)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.directory","title":"<code>directory</code>  <code>property</code>","text":"<p>directory where the model ran</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.enforce_stability","title":"<code>enforce_stability</code>  <code>property</code>","text":"<p>whether to enforce AMD-stability</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta1_fwhm_prior","title":"<code>eta1_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for the GP 'amplitude' on the FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta1_prior","title":"<code>eta1_prior</code>  <code>property</code>","text":"<p>Prior for the GP 'amplitude' on the RVs</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta2_fwhm_prior","title":"<code>eta2_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for \u03b72, the GP correlation timescale, on the FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta2_prior","title":"<code>eta2_prior</code>  <code>property</code>","text":"<p>Prior for \u03b72, the GP correlation timescale, on the RVs</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta3_fwhm_prior","title":"<code>eta3_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for \u03b73, the GP period, on the FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta3_prior","title":"<code>eta3_prior</code>  <code>property</code>","text":"<p>Prior for \u03b73, the GP period, on the RVs</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta4_fwhm_prior","title":"<code>eta4_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for \u03b74, the recurrence timescale or (inverse) harmonic complexity, on the FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.eta4_prior","title":"<code>eta4_prior</code>  <code>property</code>","text":"<p>Prior for \u03b74, the recurrence timescale or (inverse) harmonic complexity, on the RVs</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.fix","title":"<code>fix</code>  <code>property</code>","text":"<p>whether the number of Keplerians is fixed</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.known_object","title":"<code>known_object</code>  <code>property</code>","text":"<p>whether the model includes (better) known extra Keplerian curve(s)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.n_known_object","title":"<code>n_known_object</code>  <code>property</code>","text":"<p>how many known objects</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.n_transiting_planet","title":"<code>n_transiting_planet</code>  <code>property</code>","text":"<p>how many transiting planets</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.npmax","title":"<code>npmax</code>  <code>property</code>","text":"<p>maximum number of Keplerians</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.quadr_fwhm_prior","title":"<code>quadr_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for the quadratic coefficient of the trend in the FWHM (in the FWHM)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.quadr_prior","title":"<code>quadr_prior</code>  <code>property</code>","text":"<p>Prior for the quadratic coefficient of the trend (in the RVs)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.share_eta2","title":"<code>share_eta2</code>  <code>property</code>","text":"<p>whether the \u03b72 parameter is shared between RVs and FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.share_eta3","title":"<code>share_eta3</code>  <code>property</code>","text":"<p>whether the \u03b73 parameter is shared between RVs and FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.share_eta4","title":"<code>share_eta4</code>  <code>property</code>","text":"<p>whether the \u03b74 parameter is shared between RVs and FWHM</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.slope_fwhm_prior","title":"<code>slope_fwhm_prior</code>  <code>property</code>","text":"<p>Prior for the slope in the FWHM (in the FWHM)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.slope_prior","title":"<code>slope_prior</code>  <code>property</code>","text":"<p>Prior for the slope (in the RVs)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.star_mass","title":"<code>star_mass</code>  <code>property</code>","text":"<p>stellar mass [Msun]</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.transiting_planet","title":"<code>transiting_planet</code>  <code>property</code>","text":"<p>whether the model includes transiting planet(s)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.trend","title":"<code>trend</code>  <code>property</code>","text":"<p>whether the model includes a polynomial trend (in the RVs)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.trend_fwhm","title":"<code>trend_fwhm</code>  <code>property</code>","text":"<p>whether the model includes a polynomial trend (in the FWHM)</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.set_known_object","title":"<code>set_known_object()</code>  <code>method descriptor</code>","text":"<p>set_known_object(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.RVFWHMmodel.RVFWHMmodel.set_transiting_planet","title":"<code>set_transiting_planet()</code>  <code>method descriptor</code>","text":"<p>set_transiting_planet(self, arg: int, /) -&gt; None</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel","title":"<code>BINARIESmodel()</code>","text":"<p>init(self, fix: bool, npmax: int, data: kima.Data.RVData) -&gt; None</p> <p>Implements a sum-of-Keplerians model where the number of Keplerians can be free. This model assumes white, uncorrelated noise. This modules is tailored for the analysis of stellar binaries through the known object mode (without it this defaults to the RVmodel) The binary can have one set of RVs or two (one on each star). This model adds apsidal  precession as a free parameter and accounts for GR and Tidal effects on the radial velocities.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool, default=True</code> <p>whether the number of Keplerians should be fixed</p> required <code>npmax</code> <code>int, default=0</code> <p>maximum number of Keplerians</p> required <code>data</code> <code>RVData</code> <p>the RV data</p> required"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.Cprior","title":"<code>Cprior</code>  <code>property</code>","text":"<p>Prior for the systemic velocity</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.Jprior","title":"<code>Jprior</code>  <code>property</code>","text":"<p>Prior for the extra white noise (jitter)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_Kprior","title":"<code>KO_Kprior</code>  <code>property</code>","text":"<p>Prior for Semi-amplitude of Binary orbit (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_Pprior","title":"<code>KO_Pprior</code>  <code>property</code>","text":"<p>Prior for Period of Binary orbit (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_cosiprior","title":"<code>KO_cosiprior</code>  <code>property</code>","text":"<p>Prior for cosine of the inclination of Binary orbit (+other known objects) to the line-of-sight</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_eprior","title":"<code>KO_eprior</code>  <code>property</code>","text":"<p>Prior for eccentricity of Binary orbit (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_phiprior","title":"<code>KO_phiprior</code>  <code>property</code>","text":"<p>Prior for phase of Binary orbit at the reference time (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_qprior","title":"<code>KO_qprior</code>  <code>property</code>","text":"<p>Prior for mass ratio of Binary (+other known objects), used if double lined</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_wdotprior","title":"<code>KO_wdotprior</code>  <code>property</code>","text":"<p>Prior for apsidal precession rate of Binary orbit (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.KO_wprior","title":"<code>KO_wprior</code>  <code>property</code>","text":"<p>Prior for argument of periastron of Binary orbit (+other known objects)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.binary_mass","title":"<code>binary_mass</code>  <code>property</code>","text":"<p>secondary mass [Msun]</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.binary_radius","title":"<code>binary_radius</code>  <code>property</code>","text":"<p>secondary radius [Rsun]</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.conditional","title":"<code>conditional</code>  <code>property</code>","text":"<p>(self) -&gt; kima.RVmodel.KeplerianConditionalPrior</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.cubic_prior","title":"<code>cubic_prior</code>  <code>property</code>","text":"<p>Prior for the cubic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>degree of the polynomial trend</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.directory","title":"<code>directory</code>  <code>property</code>","text":"<p>directory where the model ran</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.double_lined","title":"<code>double_lined</code>  <code>property</code>","text":"<p>whether the data is for a double lined binary, and has two sets of RVs for each epoch</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.eclipsing","title":"<code>eclipsing</code>  <code>property</code>","text":"<p>whether binary is eclipsing and the inclination can be fixed to 90, defaults to true. If false, default prior is uniform in cosi</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.enforce_stability","title":"<code>enforce_stability</code>  <code>property</code>","text":"<p>whether to enforce AMD-stability</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.fix","title":"<code>fix</code>  <code>property</code>","text":"<p>whether the number of Keplerians is fixed</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.known_object","title":"<code>known_object</code>  <code>property</code>","text":"<p>whether to include (better) known extra Keplerian curve(s), should be true for BINARIESmodel</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.n_known_object","title":"<code>n_known_object</code>  <code>property</code>","text":"<p>how many known objects, should be &gt;=1 for BINARIESmodel</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.nu_prior","title":"<code>nu_prior</code>  <code>property</code>","text":"<p>Prior for the degrees of freedom of the Student-t likelihood</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.offsets_prior","title":"<code>offsets_prior</code>  <code>property</code>","text":"<p>Common prior for the between-instrument offsets</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.quadr_prior","title":"<code>quadr_prior</code>  <code>property</code>","text":"<p>Prior for the quadratic coefficient of the trend</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.relativistic_correction","title":"<code>relativistic_correction</code>  <code>property</code>","text":"<p>whether to perform the GR correction</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.slope_prior","title":"<code>slope_prior</code>  <code>property</code>","text":"<p>Prior for the slope</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.star_mass","title":"<code>star_mass</code>  <code>property</code>","text":"<p>primary mass [Msun]</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.star_radius","title":"<code>star_radius</code>  <code>property</code>","text":"<p>primary radius [Rsun]</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.studentt","title":"<code>studentt</code>  <code>property</code>","text":"<p>use a Student-t distribution for the likelihood (instead of Gaussian)</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.tidal_correction","title":"<code>tidal_correction</code>  <code>property</code>","text":"<p>whether to perform the tidal correction</p>"},{"location":"docs/API/kima/#kima.BINARIESmodel.BINARIESmodel.trend","title":"<code>trend</code>  <code>property</code>","text":"<p>whether the model includes a polynomial trend</p>"},{"location":"docs/API/kima/#run","title":"Run","text":"<p>To run the sampler and estimate the posterior for the model parameters  just call <code>kima.run</code></p>"},{"location":"docs/API/kima/#example_2","title":"Example:","text":"<pre><code>import kima\n\nkima.run(model, steps=1000, num_threads=4)\n</code></pre> <code>kima.run</code> API <p>run(m: kima.RVmodel.RVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.GPmodel.GPmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.RVFWHMmodel.RVFWHMmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.TRANSITmodel.TRANSITmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.OutlierRVmodel.OutlierRVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.BINARIESmodel.BINARIESmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.GAIAmodel.GAIAmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.RVGAIAmodel.RVGAIAmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.RVFWHMRHKmodel.RVFWHMRHKmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.ETVmodel.ETVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None run(m: kima.SPLEAFmodel.SPLEAFmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</p> <p>Overloaded function.</p> <ol> <li><code>run(m: kima.RVmodel.RVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></li> </ol> <p>Run the DNest4 sampler with the given model</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(RVmodel, GPmodel, ...)</code> <p>The model</p> required <code>steps</code> <code>int</code> <p>How many steps to run. Default is 100.</p> required <code>num_threads</code> <code>int</code> <p>How many threads to use for parallel processing. Default is 1.</p> required <code>num_particles</code> <code>int</code> <p>Number of MCMC particles. Default is 1.</p> required <code>new_level_interval</code> <code>int</code> <p>Number of steps required to create a new level. Default is 2000.</p> required <code>save_interval</code> <code>int</code> <p>Number of steps between saves. Default is 100.</p> required <code>thread_steps</code> <code>int</code> <p>Number of independent steps on each thread. Default is 10.</p> required <code>max_num_levels</code> <code>int</code> <p>Maximum number of levels, or 0 if it should be determined automatically. Default is 0.</p> required <code>lambda_</code> <code>int</code> <p>DOC. Default is 10.0</p> required <code>beta</code> <code>int</code> <p>DOC. Default is 100.0,</p> required <code>compression</code> <code>int</code> <p>DOC. Default is exp(1.0)</p> required <code>seed</code> <code>int</code> <p>Random number seed value, or 0 to use current time. Default is 0.</p> required <code>print_thin</code> <code>int</code> <p>Thinning steps for terminal output. Default is 50.</p> required <ol> <li> <p><code>run(m: kima.GPmodel.GPmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.RVFWHMmodel.RVFWHMmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.TRANSITmodel.TRANSITmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.OutlierRVmodel.OutlierRVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.BINARIESmodel.BINARIESmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.GAIAmodel.GAIAmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.RVGAIAmodel.RVGAIAmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.RVFWHMRHKmodel.RVFWHMRHKmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.ETVmodel.ETVmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> <li> <p><code>run(m: kima.SPLEAFmodel.SPLEAFmodel, steps: int = 100, num_threads: int = 1, num_particles: int = 1, new_level_interval: int = 2000, save_interval: int = 100, thread_steps: int = 10, max_num_levels: int = 0, lambda_: float = 10.0, beta: float = 100.0, compression: float = 2.718281828459045, seed: int = 0, print_thin: int = 50) -&gt; None</code></p> </li> </ol>"},{"location":"docs/API/kima/#distributions","title":"Distributions","text":"<p>The <code>distributions</code> sub-package contains the implementation of several probability distributions  that can be used as priors for a model parameter. All distributions have standard parameterizations,  as you would find e.g. in Wikipedia. Some distributions have a corresponding  <code>Truncated</code> version which truncates the support of the distribution to an interval $ [{\\rm lower}, {\\rm upper} ]$.</p>"},{"location":"docs/API/kima/#example_3","title":"Example:","text":"<pre><code>from kima import distributions\n\nparameter_prior = distributions.Gaussian(10, 1)\n</code></pre> <code>kima.distributions</code> API"},{"location":"docs/API/kima/#kima.distributions.Cauchy","title":"<code>Cauchy()</code>","text":"<p>Cauchy distribution</p> <p>init(self, loc: float, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Cauchy.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Cauchy.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Cauchy.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Cauchy.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Cauchy.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Exponential","title":"<code>Exponential()</code>","text":"<p>Exponential distribution</p> <p>init(self, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Exponential.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Exponential.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Exponential.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture","title":"<code>ExponentialRayleighMixture()</code>","text":"<p>docs</p> <p>init(self, weight: float, scale: float, sigma: float) -&gt; None</p> <p>docs</p>"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.sigma","title":"<code>sigma</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.weight","title":"<code>weight</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.ExponentialRayleighMixture.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Fixed","title":"<code>Fixed()</code>","text":"<p>'Fixed' distribution</p> <p>init(self, value: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Fixed.val","title":"<code>val</code>  <code>property</code>","text":"<p>Fixed value of the parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Fixed.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Fixed.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Fixed.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Gaussian","title":"<code>Gaussian()</code>","text":"<p>Gaussian distribution</p> <p>init(self, loc: float, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Gaussian.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Gaussian.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Gaussian.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Gaussian.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Gaussian.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.GaussianMixture","title":"<code>GaussianMixture()</code>","text":"<p>Mixture of Gaussian distributions</p> <p>init(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float]) -&gt; None init(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float], lower: float, upper: float) -&gt; None init(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float], weights: collections.abc.Sequence[float], lower: float, upper: float) -&gt; None</p> <p>Overloaded function.</p> <ol> <li><code>__init__(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float]) -&gt; None</code></li> </ol> <p>Instantiates a mixture of Gaussian distributions from lists of means and sigmas, with equal weights</p> <ol> <li><code>__init__(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float], lower: float, upper: float) -&gt; None</code></li> </ol> <p>Instantiates a mixture of Gaussian distributions from lists of means and sigmas, with equal weights, truncated to [lower, upper]</p> <ol> <li><code>__init__(self, means: collections.abc.Sequence[float], sigmas: collections.abc.Sequence[float], weights: collections.abc.Sequence[float], lower: float, upper: float) -&gt; None</code></li> </ol> <p>Instantiates a mixture of Gaussian distributions from lists of means, sigmas, and weights, truncated to [lower, upper]</p>"},{"location":"docs/API/kima/#kima.distributions.GaussianMixture.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.GaussianMixture.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.GaussianMixture.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.HalfGaussian","title":"<code>HalfGaussian()</code>","text":"<p>Half-Gaussian distribution</p> <p>init(self, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.HalfGaussian.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.HalfGaussian.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.HalfGaussian.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.HalfGaussian.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseGamma","title":"<code>InverseGamma()</code>","text":"<p>Inverse gamma distribution</p> <p>init(self, alpha: float, beta: float) -&gt; None</p> <p>Inverse gamma distribution</p>"},{"location":"docs/API/kima/#kima.distributions.InverseGamma.alpha","title":"<code>alpha</code>  <code>property</code>","text":"<p>Shape parameter \u03b1</p>"},{"location":"docs/API/kima/#kima.distributions.InverseGamma.beta","title":"<code>beta</code>  <code>property</code>","text":"<p>Scale parameter \u03b2</p>"},{"location":"docs/API/kima/#kima.distributions.InverseGamma.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseGamma.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseGamma.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseMoment","title":"<code>InverseMoment()</code>","text":"<p>InverseMoment prior</p> <p>init(self, tau: float, kmax: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.InverseMoment.kmax","title":"<code>kmax</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.InverseMoment.tau","title":"<code>tau</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.InverseMoment.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseMoment.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.InverseMoment.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy","title":"<code>Kumaraswamy()</code>","text":"<p>Kumaraswamy distribution (similar to a Beta distribution)</p> <p>init(self, a: float, b: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy.a","title":"<code>a</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy.b","title":"<code>b</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Kumaraswamy.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Laplace","title":"<code>Laplace()</code>","text":"<p>Laplace distribution</p> <p>init(self, loc: float, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Laplace.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Laplace.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.Laplace.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Laplace.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Laplace.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.LogUniform","title":"<code>LogUniform()</code>","text":"<p>LogUniform distribution (sometimes called reciprocal or Jeffrey's distribution)</p> <p>init(self, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.LogUniform.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.LogUniform.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.LogUniform.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.LogUniform.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.LogUniform.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform","title":"<code>ModifiedLogUniform()</code>","text":"<p>ModifiedLogUniform distribution</p> <p>init(self, knee: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform.knee","title":"<code>knee</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.ModifiedLogUniform.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Pareto","title":"<code>Pareto()</code>","text":"<p>Pareto distribution</p> <p>init(self, min: float, alpha: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Pareto.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Pareto.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Pareto.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.RNG","title":"<code>RNG()</code>","text":"<p>init(self, seed: int) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.RNG.rand","title":"<code>rand()</code>  <code>method descriptor</code>","text":"<p>rand(self) -&gt; float</p> <p>Uniform(0, 1)</p>"},{"location":"docs/API/kima/#kima.distributions.RNG.rand_int","title":"<code>rand_int()</code>  <code>method descriptor</code>","text":"<p>rand_int(self, arg: int, /) -&gt; int</p> <p>IntegerUniform(0, N)</p>"},{"location":"docs/API/kima/#kima.distributions.Rayleigh","title":"<code>Rayleigh()</code>","text":"<p>Rayleigh distribution</p> <p>init(self, scale: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Rayleigh.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Rayleigh.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Rayleigh.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Rayleigh.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior","title":"<code>SingleTransitPeriodPrior()</code>","text":"<p>Prior for the orbital period when a single planet transit was observed</p> <p>init(self, W: float, L: float, Pmax: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.L","title":"<code>L</code>  <code>property</code>","text":"<p>Mid-transit time minus the start of the observational window</p>"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.Pmax","title":"<code>Pmax</code>  <code>property</code>","text":"<p>Maximum orbital period</p>"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.W","title":"<code>W</code>  <code>property</code>","text":"<p>Observational window</p>"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.SingleTransitPeriodPrior.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Triangular","title":"<code>Triangular()</code>","text":"<p>Triangular distribution</p> <p>init(self, lower: float, center: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Triangular.center","title":"<code>center</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Triangular.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Triangular.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Triangular.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Triangular.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Triangular.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy","title":"<code>TruncatedCauchy()</code>","text":"<p>docs</p> <p>init(self, loc: float, scale: float, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedCauchy.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential","title":"<code>TruncatedExponential()</code>","text":"<p>Exponential distribution truncated to [lower, upper]</p> <p>init(self, scale: float, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedExponential.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian","title":"<code>TruncatedGaussian()</code>","text":"<p>Gaussian distribution truncated to [lower, upper] interval</p> <p>init(self, loc: float, scale: float, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>Lower truncation boundary</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>Upper truncation boundary</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedGaussian.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto","title":"<code>TruncatedPareto()</code>","text":"<p>Pareto distribution truncated to [lower, upper] interval</p> <p>init(self, min: float, alpha: float, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.alpha","title":"<code>alpha</code>  <code>property</code>","text":"<p>Scale parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.min","title":"<code>min</code>  <code>property</code>","text":"<p>Location parameter</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedPareto.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh","title":"<code>TruncatedRayleigh()</code>","text":"<p>Rayleigh distribution truncated to [lower, upper] interval</p> <p>init(self, scale: float, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.TruncatedRayleigh.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.Uniform","title":"<code>Uniform()</code>","text":"<p>Uniform distribuion in [lower, upper]</p> <p>init(self, lower: float, upper: float) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.Uniform.lower","title":"<code>lower</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Uniform.upper","title":"<code>upper</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"docs/API/kima/#kima.distributions.Uniform.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Uniform.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.Uniform.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#kima.distributions.UniformAngle","title":"<code>UniformAngle()</code>","text":"<p>Uniform distribuion in [0, 2*PI]</p> <p>init(self) -&gt; None</p>"},{"location":"docs/API/kima/#kima.distributions.UniformAngle.cdf","title":"<code>cdf()</code>  <code>method descriptor</code>","text":"<p>cdf(self, x: float) -&gt; float</p> <p>Cumulative distribution function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the CDF</p> required"},{"location":"docs/API/kima/#kima.distributions.UniformAngle.logpdf","title":"<code>logpdf()</code>  <code>method descriptor</code>","text":"<p>logpdf(self, x: float) -&gt; float</p> <p>Logarithm of the probability density function evaluated at <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>point at which to evaluate the PDF</p> required"},{"location":"docs/API/kima/#kima.distributions.UniformAngle.ppf","title":"<code>ppf()</code>  <code>method descriptor</code>","text":"<p>ppf(self, q: float) -&gt; float</p> <p>Percent point function (inverse of cdf) evaluated at <code>q</code></p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float</code> <p>point at which to evaluate the PPF</p> required"},{"location":"docs/API/kima/#keplerian","title":"Keplerian","text":"<p>Finally, even though it sits at the core of what kima does,  there is the keplerian function:</p> <code>kima.keplerian</code> API <p>keplerian(t: collections.abc.Sequence[float], P: float, K: float, ecc: float, w: float, M0: float, M0_epoch: float) -&gt; numpy.ndarray[dtype=float64]</p> <p>Calculate the Keplerian curve at times <code>t</code></p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>array</code> <p>Times at which to calculate the Keplerian function</p> required <code>P</code> <code>float</code> <p>Orbital period [days]</p> required <code>K</code> <code>float</code> <p>Semi-amplitude</p> required <code>ecc</code> <code>float</code> <p>Orbital eccentricity</p> required <code>w</code> <code>float</code> <p>Argument of periastron [rad]</p> required <code>M0</code> <code>float</code> <p>Mean anomaly at the epoch [rad]</p> required <code>M0_epoch</code> <code>float</code> <p>Reference epoch for the mean anomaly (M=0 at this time) [days]</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>array</code> <p>Keplerian function evaluated at input times <code>t</code></p>"},{"location":"docs/API/pykima/","title":"API documentation for <code>pykima</code>","text":"<p>kima itself is written in C++, to leverage the increased performance. The Python bindings created with nanobind expose most of the functionality of the data (RVData) and model classes (e.g. RVmodel, GPmodel, etc.), as well as the sampler (kima.run).</p> <p>To analyse the results and create figures, the <code>pykima</code> sub-package was created. It can be used in an IPython shell, a Jupyter notebook, or the standard Python interpreter.</p> <p>The typical interface with the results of a run is through the [<code>KimaResults</code>][pykima.results.KimaResults] class created by calling the [<code>kima.load_results</code>][pykima.results.load_results] function</p> <pre><code>model ...\nres = kima.load_results(model)\n</code></pre> <code>KimaResults</code> class <p>A class to hold, analyse, and display the results from kima</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The type of kima model</p> <code>priors</code> <code>dict</code> <p>A dictionary with the priors used in the model</p> <code>ESS</code> <code>int</code> <p>Effective sample size</p> <code>evidence</code> <code>float</code> <p>The log-evidence (\\(\\ln Z\\)) of the model</p> <code>information</code> <code>float</code> <p>The Kullback-Leibler divergence between prior and posterior</p> <code>data</code> <code>data_holder</code> <p>The data</p> <code>posteriors</code> <code>posterior_holder</code> <p>The marginal posterior samples</p> <code>kima.load_results</code> API <p>Load the results from a kima run </p> <p>Parameters:</p> Name Type Description Default <code>model_or_file</code> <code>str or Model</code> <p>If a string, load results from a pickle or zip file. If a model (e.g. <code>kima.RVmodel</code>), load results from that particular model and from the directory where it ran</p> required <code>data</code> <code>RVData</code> <p>An instance of <code>kima.RVData</code> to use instead of <code>model.data</code> Warning: untested!</p> <code>None</code> <code>diagnostic</code> <code>bool</code> <p>Show the diagnostic plots</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print some information about the results</p> <code>True</code> <code>moreSamples</code> <code>int</code> <p>The total number of posterior samples will be equal to  ESS * moreSamples</p> <code>1</code> <code>n_resample_logX</code> <code>int</code> <p>Number of times to resample the logX values in order to estimate the NS uncertainty in logZ, I, etc.</p> <code>1</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If <code>model_or_file</code> is a string and the file does not exist</p> <p>Returns:</p> Name Type Description <code>res</code> <code>KimaResults</code> <p>An instance of <code>KimaResults</code> holding the results of the run</p> <p>A number of convenience plots are redirected from the <code>pykima.display</code> module into any <code>KimaResults</code> instance:</p> <pre><code>res.plot_posterior_np()\n\nres.plot_posterior_period()\n</code></pre> <p>Note</p> <p>Several of the plotting functions are aliased and numbered, as in</p> <pre><code>res.plot1 = res.plot_posterior_np\n</code></pre> <p>This can be convenient, but it's mostly for historical reasons and  the API might change at any time. Therefore, these funcions are not documented.</p> <code>kima.pykima.analysis</code> API <code>kima.pykima.display</code> API <code>kima.pykima.utils</code> API <p>Small (but sometimes important) utility functions</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.parameter_priors","title":"<code>parameter_priors</code>  <code>property</code>","text":"<p>A list of priors which can be indexed using self.indices</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.load","title":"<code>load(filename=None, diagnostic=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a KimaResults object from the current directory, a pickle file, or a zip file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>If given, load the model from this file. Can be a zip or pickle file. Defaults to None.</p> <code>None</code> <code>diagnostic</code> <code>bool</code> <p>Whether to plot the DNest4 diagnotics. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Extra keyword arguments passed to <code>showresults</code></p> <code>{}</code> <p>Returns:</p> Name Type Description <code>res</code> <code>KimaResults</code> <p>An object holding the results</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.save_pickle","title":"<code>save_pickle(filename=None, postfix=None, verbose=True)</code>","text":"<p>Pickle this KimaResults object into a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file where to save the model. If not given, a unique name will be generated from the properties of the model.</p> <code>None</code> <code>postfix</code> <code>str</code> <p>A string to add to the filename, after the timestamp.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print a message. Defaults to True.</p> <code>True</code> <p>Returns:     filename (str): The name of the pickle file where the model was saved</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.save_zip","title":"<code>save_zip(filename, verbose=True)</code>","text":"<p>Save this KimaResults object and the text files into a zip.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file where to save the model</p> required <code>verbose</code> <code>bool</code> <p>Print a message. Defaults to True.</p> <code>True</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.get_marginals","title":"<code>get_marginals()</code>","text":"<p>Get the marginal posteriors from the posterior_sample matrix. They go into self.T, self.A, self.E, etc</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.get_medians","title":"<code>get_medians()</code>","text":"<p>return the median values of all the parameters</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.log_prior","title":"<code>log_prior(sample, debug=False)</code>","text":"<p>Calculate the log prior for a given sample</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>sample for which to calculate the log prior</p> required Tip <p>To evaluate at all posterior samples, consider using</p> <pre><code>np.apply_along_axis(self.log_prior, 1, self.posterior_sample)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.map_sample","title":"<code>map_sample(Np=None, mask=None, printit=True, from_posterior=False)</code>  <code>cached</code>","text":"<p>Get the maximum a posteriori (MAP) sample.</p> Note <p>This requires recalculation of the prior for all samples, so it can be a bit slow, depending on the number of posterior samples.</p> <p>Parameters:</p> Name Type Description Default <code>Np</code> <code>int</code> <p>If given, select only samples with that number of planets.</p> <code>None</code> <code>printit</code> <code>bool</code> <p>Whether to print the sample.</p> <code>True</code> <code>from_posterior</code> <code>bool</code> <p>If True, return the highest likelihood sample from those that represent the posterior.</p> <code>False</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.maximum_likelihood_sample","title":"<code>maximum_likelihood_sample(Np=None, printit=True, mask=None, from_posterior=False, optimize=False)</code>","text":"<p>Get the maximum likelihood sample. </p> <p>By default, this is the highest likelihood sample found by DNest4.</p> Note <p>If <code>from_posterior=True</code>, the returned sample may change, due to random choices, between different calls to <code>load_results</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Np</code> <code>int</code> <p>If given, select only samples with that number of planets.</p> <code>None</code> <code>printit</code> <code>bool</code> <p>Whether to print the sample</p> <code>True</code> <code>from_posterior</code> <code>bool</code> <p>If True, return the highest likelihood sample from those that represent the posterior. </p> <code>False</code> <code>optimize</code> <code>bool</code> <p>If True, optimize the likelihood, starting from the maximum likelihood sample.</p> <code>False</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.median_sample","title":"<code>median_sample(Np=None, printit=True)</code>","text":"<p>Get the median posterior sample.</p> Warning <p>Unless all posteriors are Gaussian or otherwise well-behaved, the median sample is usually not the appropriate choice for plots, etc. </p> <p>Parameters:</p> Name Type Description Default <code>Np</code> <code>int</code> <p>If given, select only samples with that number of planets.</p> <code>None</code> <code>printit</code> <code>bool</code> <p>Whether to print the sample</p> <code>True</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.eval_model","title":"<code>eval_model(sample, t=None, include_planets=True, include_known_object=True, include_transiting_planet=True, include_indicator_correlations=True, include_trend=True, single_planet=None, except_planet=None)</code>","text":"<p>Evaluate the deterministic part of the model at one posterior <code>sample</code>.</p> <p>If <code>t</code> is None, use the observed times.</p> Note <p>Instrument offsets are only added if <code>t</code> is None, but the systemic velocity is always added.</p> Note <p>This function does not evaluate the GP component of the model.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>One posterior sample, with shape (npar,)</p> required <code>t</code> <code>array</code> <p>Times at which to evaluate the model, or None to use observed times</p> <code>None</code> <code>include_planets</code> <code>bool</code> <p>Whether to include the contribution from the planets</p> <code>True</code> <code>include_known_object</code> <code>bool</code> <p>Whether to include the contribution from the known object planet(s)</p> <code>True</code> <code>include_transiting_planet</code> <code>bool</code> <p>Whether to include the contribution from the transiting planet(s)</p> <code>True</code> <code>include_indicator_correlations</code> <code>bool</code> <p>Whether to include the indicator correlation model</p> <code>True</code> <code>include_trend</code> <code>bool</code> <p>Whether to include the contribution from the trend</p> <code>True</code> <code>single_planet</code> <code>int</code> <p>Index of a single planet to include in the model, starting at 1. Use positive values (1, 2, ...) for the Np planets and negative values (-1, -2, ...) for the known object and transiting planets.</p> <code>None</code> <code>except_planet</code> <code>Union[int, List]</code> <p>Index (or list of indices) of a single planet to exclude from the model, starting at 1. Use positive values (1, 2, ...) for the Np planets and negative values (-1, -2, ...) for the known object and transiting planets.</p> <code>None</code> Tip <p>To evaluate at all posterior samples, consider using</p> <pre><code>np.apply_along_axis(self.eval_model, 1, self.posterior_sample)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.planet_model","title":"<code>planet_model(sample, t=None, include_known_object=True, include_transiting_planet=True, single_planet=None, except_planet=None)</code>","text":"<p>Evaluate the planet part of the model at one posterior <code>sample</code>.</p> <p>If <code>t</code> is None, use the observed times. </p> Note <p>This function does not evaluate the GP component of the model nor the systemic velocity and instrument offsets.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>One posterior sample, with shape (npar,)</p> required <code>t</code> <code>array</code> <p>Times at which to evaluate the model, or None to use observed times</p> <code>None</code> <code>include_known_object</code> <code>bool</code> <p>Whether to include the contribution from the known object planet(s)</p> <code>True</code> <code>include_transiting_planet</code> <code>bool</code> <p>Whether to include the contribution from the transiting planet(s)</p> <code>True</code> <code>single_planet</code> <code>int</code> <p>Index of a single planet to include in the model, starting at 1. Use positive values (1, 2, ...) for the Np planets and negative values (-1, -2, ...) for the known object and transiting planets.</p> <code>None</code> <code>except_planet</code> <code>Union[int, List]</code> <p>Index (or list of indices) of a single planet to exclude from the model, starting at 1. Use positive values (1, 2, ...) for the Np planets and negative values (-1, -2, ...) for the known object and transiting planets.</p> <code>None</code> Tip <p>To evaluate at all posterior samples, consider using</p> <pre><code>np.apply_along_axis(self.planet_model, 1, self.posterior_sample)\n</code></pre> <p>Examples:</p> <p>To get the Keplerian contribution from the first planet in a posterior sample <code>p</code> use:</p> <pre><code>res.planet_model(p, single_planet=1)\n</code></pre> <p>For, e.g., the second known object in the model, use:</p> <pre><code>res.planet_model(p, single_planet=-2)\n</code></pre> <p>or to get the contributions from all planets except that one</p> <pre><code>res.planet_model(p, except_planet=-2)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.stochastic_model","title":"<code>stochastic_model(sample, t=None, return_std=False, derivative=False, include_jitters=True, **kwargs)</code>","text":"<p>Evaluate the stochastic part of the model (GP) at one posterior sample.</p> <p>If <code>t</code> is None, use the observed times.  </p> Note <p>Instrument offsets are only added if <code>t</code> is None, but the systemic velocity is always added.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>One posterior sample, with shape (npar,)</p> required <code>t</code> <code>ndarray</code> <p>Times at which to evaluate the model, or <code>None</code> to use observed times</p> <code>None</code> <code>return_std</code> <code>bool</code> <p>Whether to return the standard deviation of the predictive. Default is False.</p> <code>False</code> <code>derivative</code> <code>bool</code> <p>Return the first time derivative of the GP prediction instead</p> <code>False</code> <code>include_jitters</code> <code>bool</code> <p>Whether to include the jitter values in <code>sample</code> in the prediction</p> <code>True</code> Tip <p>To evaluate at all posterior samples, consider using</p> <pre><code>np.apply_along_axis(res.stochastic_model, 1, res.posterior_sample)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.full_model","title":"<code>full_model(sample, t=None, **kwargs)</code>","text":"<p>Evaluate the full model at one posterior sample, including the GP. If <code>t</code> is <code>None</code>, use the observed times. Instrument offsets are only added if <code>t</code> is <code>None</code>, but the systemic velocity is always added.</p> <p>To evaluate at all posterior samples, consider using</p> <pre><code>np.apply_along_axis(self.full_model, 1, self.posterior_sample)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>One posterior sample, with shape (npar,)</p> required <code>t</code> <code>ndarray</code> <p>Times at which to evaluate the model, or <code>None</code> to use observed times</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments passed directly to <code>eval_model</code></p> <code>{}</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.burst_model","title":"<code>burst_model(sample, t=None, v=None)</code>","text":"<p>For models with multiple instruments, this function \"bursts\" the computed RV into <code>n_instruments</code> individual arrays. This is mostly useful for plotting the RV model together with the original data.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>One posterior sample, with shape (npar,)</p> required <code>t</code> <code>array</code> <p>Times at which to evaluate the model</p> <code>None</code> <code>v</code> <code>array</code> <p>Pre-computed RVs. If <code>None</code>, calls <code>self.eval_model</code></p> <code>None</code>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.from_prior","title":"<code>from_prior(n=1)</code>","text":"<p>Generate <code>n</code> samples from the priors for all parameters.</p>"},{"location":"docs/API/pykima/#kima.pykima.results.KimaResults.print_results","title":"<code>print_results(show_prior=False)</code>","text":"<p>Print a summary of the results, showing the posterior estimates for each parameter.</p> <p>Parameters:</p> Name Type Description Default <code>show_prior</code> <code>bool</code> <p>Whether to show the prior distribution.</p> <code>False</code> Note <p>This function is heavily inspired by a similar implementation in UltraNest.</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.np_most_probable","title":"<code>np_most_probable(results)</code>","text":"<p>Return the value of Np with the highest posterior probability.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>KimaResults</code> <p>A results instance</p> required"},{"location":"docs/API/pykima/#kima.pykima.analysis.np_bayes_factor_threshold","title":"<code>np_bayes_factor_threshold(results, threshold=150)</code>","text":"<p>Return the value of Np supported by the data considering a posterior ratio (Bayes factor) threshold.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>KimaResults</code> <p>A results instance</p> required <code>threshold</code> <code>float</code> <p>Posterior ratio threshold.</p> <code>150</code>"},{"location":"docs/API/pykima/#kima.pykima.analysis.np_posterior_threshold","title":"<code>np_posterior_threshold(results, threshold=0.9)</code>","text":"<p>Return the value of Np supported by the data considering an absolute posterior probability threshold.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>KimaResults</code> <p>A results instance</p> required <code>threshold</code> <code>float</code> <p>Posterior probability threshold</p> <code>0.9</code>"},{"location":"docs/API/pykima/#kima.pykima.analysis.get_planet_mass","title":"<code>get_planet_mass(P, K, e, star_mass=1.0, full_output=False)</code>","text":"<p>Calculate the planet (minimum) mass, \\(M_p \\sin i\\), given orbital period <code>P</code>, semi-amplitude <code>K</code>, eccentricity <code>e</code>, and stellar mass. If <code>star_mass</code> is a tuple with (estimate, uncertainty), this (Gaussian) uncertainty will be taken into account in the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Union[float, ndarray]</code> <p>orbital period [days]</p> required <code>K</code> <code>Union[float, ndarray]</code> <p>semi-amplitude [m/s]</p> required <code>e</code> <code>Union[float, ndarray]</code> <p>orbital eccentricity</p> required <code>star_mass</code> <code>Union[float, Tuple]</code> <p>stellar mass, or (mass, uncertainty) [Msun]</p> <code>1.0</code> <p>This function returns different results depending on the inputs.</p> <p>If <code>P</code>, <code>K</code>, and <code>e</code> are floats and <code>star_mass</code> is a float</p> <p>Returns:</p> Name Type Description <code>Msini</code> <code>float</code> <p>planet mass, in \\(M_{\\rm Jup}\\)</p> <code>Msini</code> <code>float</code> <p>planet mass, in \\(M_{\\rm Earth}\\)</p> <p>If <code>P</code>, <code>K</code>, and <code>e</code> are floats and <code>star_mass</code> is a tuple</p> <p>Returns:</p> Name Type Description <code>Msini</code> <code>tuple</code> <p>planet mass and uncertainty, in \\(M_{\\rm Jup}\\)</p> <code>Msini</code> <code>tuple</code> <p>planet mass and uncertainty, in \\(M_{\\rm Earth}\\)</p> <p>If <code>P</code>, <code>K</code>, and <code>e</code> are arrays and <code>full_output=True</code></p> <p>Returns:</p> Name Type Description <code>m_Msini</code> <code>float</code> <p>posterior mean for the planet mass, in \\(M_{\\rm Jup}\\)</p> <code>s_Msini</code> <code>float</code> <p>posterior standard deviation for the planet mass, in \\(M_{\\rm Jup}\\)</p> <code>Msini</code> <code>array</code> <p>posterior samples for the planet mass, in \\(M_{\\rm Jup}\\)</p> <p>If <code>P</code>, <code>K</code>, and <code>e</code> are arrays and <code>full_output=False</code></p> <p>Returns:</p> Name Type Description <code>m_Msini</code> <code>float</code> <p>posterior mean for the planet mass, in \\(M_{\\rm Jup}\\)</p> <code>s_Msini</code> <code>float</code> <p>posterior standard deviation for the planet mass, in \\(M_{\\rm Jup}\\)</p> <code>m_Msini</code> <code>float</code> <p>posterior mean for the planet mass, in \\(M_{\\rm Earth}\\)</p> <code>s_Msini</code> <code>float</code> <p>posterior standard deviation for the planet mass, in \\(M_{\\rm Earth}\\)</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.get_planet_semimajor_axis","title":"<code>get_planet_semimajor_axis(P, K, star_mass=1.0, full_output=False)</code>","text":"<p>Calculate the semi-major axis of the planet's orbit given orbital period <code>P</code>, semi-amplitude <code>K</code>, and stellar mass.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Union[float, ndarray]</code> <p>orbital period [days]</p> required <code>K</code> <code>Union[float, ndarray]</code> <p>semi-amplitude [m/s]</p> required <code>star_mass</code> <code>Union[float, Tuple]</code> <p>stellar mass, or (mass, uncertainty) [Msun]</p> <code>1.0</code> <p>This function returns different results depending on the inputs.</p> <p>If <code>P</code> and <code>K</code> are floats and <code>star_mass</code> is a float</p> <p>Returns:</p> Name Type Description <code>a</code> <code>float</code> <p>planet semi-major axis, in AU</p> <p>If <code>P</code> and <code>K</code> are floats and <code>star_mass</code> is a tuple</p> <p>Returns:</p> Name Type Description <code>a</code> <code>tuple</code> <p>semi-major axis and uncertainty, in AU</p> <p>If <code>P</code> and <code>K</code> are arrays and <code>full_output=True</code></p> <p>Returns:</p> Name Type Description <code>m_a</code> <code>float</code> <p>posterior mean for the semi-major axis, in AU</p> <code>s_a</code> <code>float</code> <p>posterior standard deviation for the semi-major axis, in AU</p> <code>a</code> <code>array</code> <p>posterior samples for the semi-major axis, in AU</p> <p>If <code>P</code> and <code>K</code> are arrays and <code>full_output=False</code></p> <p>Returns:</p> Name Type Description <code>m_a</code> <code>float</code> <p>posterior mean for the semi-major axis, in AU</p> <code>s_a</code> <code>float</code> <p>posterior standard deviation for the semi-major axis, in AU</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.get_planet_mass_and_semimajor_axis","title":"<code>get_planet_mass_and_semimajor_axis(P, K, e, star_mass=1.0, full_output=False, verbose=False)</code>","text":"<p>Calculate the planet (minimum) mass Msini and the semi-major axis given orbital period <code>P</code>, semi-amplitude <code>K</code>, eccentricity <code>e</code>, and stellar mass. If star_mass is a tuple with (estimate, uncertainty), this (Gaussian) uncertainty will be taken into account in the calculation.</p> Units <p>P [days] K [m/s] e [] star_mass [Msun]</p> <p>Returns:     (M, A) where         M is the output of get_planet_mass         A is the output of get_planet_semimajor_axis</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.FIP","title":"<code>FIP(results, plot=True, show_peaks=True, oversampling=1, include_aliases=False, show_ESS=True)</code>","text":"<p>Calculate (and plot) the True and False Inclusion Probability (TIP/FIP)</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>KimaResults</code> <p>The <code>KimaResults</code> instance</p> required <code>plot</code> <code>bool</code> <p>Plot the TIP and FIP. Defaults to True.</p> <code>True</code> <code>show_peaks</code> <code>bool</code> <p>Identify and show prominent TIP peaks. Defaults to True.</p> <code>True</code> <code>oversampling</code> <code>int</code> <p>Oversampling factor for the period binning. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>bins</code> <code>ndarray</code> <p>The period bins</p> <code>FIP</code> <code>ndarray</code> <p>The False Inclusion Probability</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.find_outliers","title":"<code>find_outliers(results, sample, threshold=10, full_output=False)</code>","text":"<p>Estimate which observations are outliers, for a model with a Student t likelihood. This function first calculates the residuals given the parameters in <code>sample</code>. Then it computes the relative probability of each residual point given a Student-t (Td) and a Gaussian (Gd) likelihoods. If the probability Td is larger than Gd (by a factor of <code>threshold</code>), the point is flagged as an outlier. The function returns an \"outlier mask\". If  <code>full_output</code> is True, it also returns the ratio Td/Gd.</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.detection_limits","title":"<code>detection_limits(results, star_mass=1.0, Np=None, bins=200, plot=True, ax=None, semi_amplitude=False, semi_major_axis=False, logX=True, return_mask=False, remove_nan=True, show_eccentricity=False, K_lines=(5, 3, 1), smooth=False, smooth_degree=3)</code>","text":"<p>Calculate detection limits using samples with more than <code>Np</code> planets. By default, this function uses the value of <code>Np</code> which passes the posterior probability threshold.</p> <p>Parameters:</p> Name Type Description Default <code>star_mass</code> <code>Union[float, Tuple]</code> <p>Stellar mass and optionally its uncertainty [in solar masses].</p> <code>1.0</code> <code>Np</code> <code>int</code> <p>Consider only posterior samples with more than <code>Np</code> planets.</p> <code>None</code> <code>bins</code> <code>int</code> <p>Number of bins at which to calculate the detection limits. The period ranges from the minimum to the maximum orbital period in the posterior.</p> <code>200</code> <code>plot</code> <code>bool</code> <p>Whether to plot the detection limits</p> <code>True</code> <code>semi_amplitude</code> <code>bool</code> <p>Show the detection limits for semi-amplitude, instead of planet mass</p> <code>False</code> <code>semi_major_axis</code> <code>bool</code> <p>Show semi-major axis in the x axis, instead of orbital period</p> <code>False</code> <code>logX</code> <code>bool</code> <p>Should X-axis bins be logarithmic?</p> <code>True</code> <code>return_mask</code> <code>bool</code> <code>False</code> <code>remove_nan</code> <code>bool</code> <p>remove bins with no counts (no posterior samples)</p> <code>True</code> <code>smooth</code> <code>bool</code> <p>Smooth the binned maximum with a polynomial</p> <code>False</code> <code>smooth_degree</code> <code>int</code> <p>Degree of the polynomial used for smoothing</p> <code>3</code> <p>Returns:</p> Name Type Description <p>P,K,E,M (ndarray): Orbital periods, semi-amplitudes, eccentricities, and planet masses used in the calculation of the detection limits. These correspond to all the posterior samples with more than <code>Np</code> planets</p> <code>s</code> <code>namedtuple</code> <p>Detection limits result, with attributes <code>max</code> and <code>bins</code>. The <code>max</code> array is in units of Earth masses, <code>bins</code> is in days.</p>"},{"location":"docs/API/pykima/#kima.pykima.analysis.hpd_grid","title":"<code>hpd_grid(sample, alpha=0.05, bw_method=None, roundto=2)</code>","text":"<p>Calculate highest posterior density (HPD) of array for given alpha.  The HPD is the minimum width Bayesian credible interval (BCI). The function works for multimodal distributions, returning more than one mode.</p> Warning <p>This function is experimental.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>array</code> <p>An array containing MCMC samples</p> required <code>alpha</code> <code>float</code> <p>Desired probability of type I error (defaults to 0.05)</p> <code>0.05</code> <code>bw_method</code> <code>float</code> <p>The method used to estimate the KDE bandwidth. See <code>scipy.stats.gaussian_kde</code></p> <code>None</code> <code>roundto</code> <code>integer</code> <p>Number of digits after the decimal point for the results</p> <code>2</code>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_posterior_np","title":"<code>plot_posterior_np(res, ax=None, errors=False, show_ESS=True, show_detected=True, show_probabilities=False, show_title=True, **kwargs)</code>","text":"<p>Plot the histogram of the posterior for Np</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>KimaResults</code> <p>The <code>KimaResults</code> instance</p> required <code>ax</code> <code>Axes</code> <p>An existing matplotlib axes where to draw the plot</p> <code>None</code> <code>errors</code> <code>bool</code> <p>Whether to estimate and display errors on the Np posterior.</p> <code>False</code> <code>show_ESS</code> <code>bool</code> <p>Display the effective sample size on the plot.</p> <code>True</code> <code>show_detected</code> <code>bool</code> <p>Highlight the detected Np in the plot (from <code>np_bayes_factor_threshold</code>).</p> <code>True</code> <code>show_probabilities</code> <code>bool</code> <p>Display the probabilities on top of the histogram bars.</p> <code>False</code> <code>show_title</code> <code>bool</code> <p>Display the title on the plot</p> <code>True</code> <code>**kwargs</code> <p>Keyword arguments to pass to the <code>ax.bar</code> method</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The matplotlib figure with the plot</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_posterior_period","title":"<code>plot_posterior_period(res, nbins=100, bins=None, plims=None, logx=True, kde=False, kde_bw=None, show_peaks=False, show_prior=False, show_year=True, show_timespan=True, show_aliases=False, include_known_object=False, include_transiting_planet=False, separate_colors=False, return_bins=False, mark_periods=None, mark_periods_text=False, **kwargs)</code>","text":"<p>Plot the histogram (or the kde) of the posterior for the orbital period(s)</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>KimaResults</code> <p>The <code>KimaResults</code> instance</p> required <code>nbins</code> <code>int</code> <p>Number of bins in the histogram</p> <code>100</code> <code>bins</code> <code>array</code> <p>Histogram bins</p> <code>None</code> <code>plims</code> <code>tuple</code> <p>Period limits, as (pmin, pmax)</p> <code>None</code> <code>logx</code> <code>bool</code> <p>Plot the x axis in lograithmic scale</p> <code>True</code> <code>kde</code> <code>bool</code> <p>Show a kernel density estimation (KDE) instead of the histogram</p> <code>False</code> <code>kde_bw</code> <code>float</code> <p>Bandwith for the KDE</p> <code>None</code> <code>show_peaks</code> <code>bool</code> <p>Try to identify prominent peaks in the posterior</p> <code>False</code> <code>show_prior</code> <code>bool</code> <p>Plot the prior together with the posterior</p> <code>False</code> <code>show_year</code> <code>bool</code> <p>Show a vertical line at 1 year</p> <code>True</code> <code>show_timespan</code> <code>bool</code> <p>Show a vertical line at the timespan of the data</p> <code>True</code> <code>show_aliases</code> <code>bool or int</code> <p>Show daily and yearly aliases for top peak(s)</p> <code>False</code> <code>separate_colors</code> <code>bool</code> <p>Show different Keplerians as different colors</p> <code>False</code> <code>return_bins</code> <code>bool</code> <p>Return the bins used for the histogram</p> <code>False</code> <code>mark_periods</code> <code>(list, tuple, array)</code> <p>Mark specific periods in the plot</p> <code>None</code> <code>mark_periods_text</code> <code>bool</code> <p>Write the period values next to the marker</p> <code>False</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The matplotlib figure with the plot</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_PKE","title":"<code>plot_PKE(res, mask=None, include_known_object=False, include_transiting_planet=False, show_prior=False, show_aliases=None, reorder_P=False, sort_by_increasing_P=False, points=True, colors_np=True, gridsize=50, **kwargs)</code>","text":"<p>Plot the 2d histograms of the posteriors for semi-amplitude and orbital period and for eccentricity and orbital period. If <code>points</code> is True, plot each posterior sample, else plot hexbins</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_gp","title":"<code>plot_gp(res, Np=None, ranges=None, show_prior=False, fig=None, axs=None, **hist_kwargs)</code>","text":"<p>Plot histograms for the GP hyperparameters. If Np is not None, highlight the samples with Np Keplerians.</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_gp_rvfwhm","title":"<code>plot_gp_rvfwhm(res, Np=None, ranges=None, show_prior=False, fig=None, **hist_kwargs)</code>","text":"<p>Plot histograms for the GP hyperparameters. If Np is not None, highlight the samples with Np Keplerians.</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_gp_corner","title":"<code>plot_gp_corner(res, include_jitters=False, ranges=None)</code>","text":"<p>Corner plot for the GP hyperparameters</p>"},{"location":"docs/API/pykima/#kima.pykima.display.corner_planet_parameters","title":"<code>corner_planet_parameters(res, fig=None, Np=None, true_values=None, period_ranges=None, include_known_object=False, include_transiting_planet=False, KO_Np=None, TR_Np=None, show_prior=False, wrap_M0=False, replace_angles_with_mass=False, star_mass=1.0, a_factor=1.0)</code>","text":"<p>Corner plots of the posterior samples for the planet parameters</p>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_vsys","title":"<code>hist_vsys(res, ax=None, show_offsets=True, show_other=False, specific=None, show_prior=False, **kwargs)</code>","text":"<p>Plot the histogram of the posterior for the systemic velocity and for the between-instrument offsets. (if the model has multiple instruments).</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>KimaResults</code> <p>The <code>KimaResults</code> instance</p> required <code>show_offsets</code> <code>bool</code> <p>Whether to plot the histograms for the between-instrument offsets</p> <code>True</code> <code>show_other</code> <code>bool</code> <p>Whether to plot the histogram for the constant offsets corresponding to the activity indicators in the corresponding models</p> <code>False</code> <code>specific</code> <code>tuple</code> <p>If not None, it should be a tuple with two instrument names (matching <code>res.instrument</code>). In that case, this function works out (and plots) the RV offset between those two instruments.</p> <code>None</code> <code>show_prior</code> <code>bool</code> <p>Whether to plot the histogram of the prior distribution</p> <code>False</code> <code>**kwargs</code> <p>Keyword arguments passed to <code>matplotlib.pyplot.hist</code></p> <code>{}</code>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_jitter","title":"<code>hist_jitter(res, show_prior=False, show_stats=False, show_title=True, show_stellar_jitter=True, ax=None, **kwargs)</code>","text":"<p>Plot the histogram of the posterior for the additional white noise</p>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_correlations","title":"<code>hist_correlations(res, show_prior=False)</code>","text":"<p>Plot the histogram of the posterior for the activity correlations</p>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_trend","title":"<code>hist_trend(res, per_year=True, ax=None, show_prior=False, show_title=True)</code>","text":"<p>Plot the histogram of the posterior for the coefficients of the trend</p>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_MA","title":"<code>hist_MA(res)</code>","text":"<p>Plot the histogram of the posterior for the MA parameters</p>"},{"location":"docs/API/pykima/#kima.pykima.display.hist_nu","title":"<code>hist_nu(res, show_prior=False, **kwargs)</code>","text":"<p>Plot the histogram of the posterior for the Student-t degrees of freedom</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_RVData","title":"<code>plot_RVData(data, **kwargs)</code>","text":"<p>Simple plot of RV data</p>"},{"location":"docs/API/pykima/#kima.pykima.display.phase_plot","title":"<code>phase_plot(res, sample, phase_axs=None, xaxis='mean anomaly', sort_by_increasing_P=False, sort_by_decreasing_K=True, highlight=None, highlight_points=None, only=None, show_titles=True, sharey=False, show_gls_residuals=False, show_outliers=False, fancy_ticks=False, **kwargs)</code>","text":"<p>Plot the planet phase curves, GP, and residuals, for a given <code>sample</code>.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>KimaResults</code> <p>The <code>KimaResults</code> instance</p> required <code>sample</code> <code>array</code> <p>Array with one posterior sample</p> required <code>phase_axs</code> <code>list[Axes]</code> <p>One or more axes for the phase plot(s)</p> <code>None</code> <code>xaxis</code> <code>str</code> <p>Plot the phase curve against 'mean anomaly' or 'mean longitude'</p> <code>'mean anomaly'</code> <code>sort_by_increasing_P</code> <code>bool</code> <p>Sort the planets by increasing period</p> <code>False</code> <code>sort_by_decreasing_K</code> <code>bool</code> <p>Sort the planets by decreasing semi-amplitude</p> <code>True</code> <code>highlight</code> <code>list</code> <p>Highlight all data points from a specific instrument</p> <code>None</code> <code>highlight_points</code> <code>list</code> <p>Highlight specific data points by index</p> <code>None</code> <code>only</code> <code>list</code> <p>Only show data from specific instrument(s)</p> <code>None</code> <code>show_titles</code> <code>bool</code> <p>Add titles to each phase plot</p> <code>True</code> <code>sharey</code> <code>bool</code> <p>Share the y-axis of the phase plots</p> <code>False</code> <code>show_gls_residuals</code> <code>bool</code> <p>Add a panel with the Lomb-Scargle periodogram of the residuals</p> <code>False</code> <code>show_outliers</code> <code>bool</code> <p>Show points identified as outliers</p> <code>False</code> <code>fancy_ticks</code> <code>bool</code> <p>Use fancy ticks for angles</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>plt.errorbar</code></p> <code>{}</code> Warning <p>This is probably the most complicated function in the whole package! For one, the layout of the axes in the figure may not always be optimal.</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_random_samples","title":"<code>plot_random_samples(res, ncurves=50, samples=None, over=0.1, ntt=5000, show_vsys=False, isolate_known_object=True, isolate_transiting_planet=True, include_jitters_in_points=False, include_jitters_in_predict=True, full_plot=False, show_outliers=False, **kwargs)</code>","text":"<p>Display the RV data together with curves from the posterior predictive. </p> <p>Parameters:</p> Name Type Description Default <code>ncurves</code> <code>int</code> <p>Number of posterior predictive curves to show. Defaults to 50.</p> <code>50</code> <code>samples</code> <code>array</code> <p>Specific posterior sample(s) to plot. Defaults to None.</p> <code>None</code> <code>over</code> <code>float</code> <p>Curves are calculated covering 100*(1 + <code>over</code>)% of the timespan of the data. Defaults to 0.1.</p> <code>0.1</code> <code>ntt</code> <code>int</code> <p>Number of points for the time grid. Defaults to 5000.</p> <code>5000</code> <code>show_vsys</code> <code>bool</code> <p>Show the systemic velocity for each sample. Defaults to False.</p> <code>False</code> <code>isolate_known_object</code> <code>bool</code> <p>Show the Keplerian curves for the known object(s), if present in the model. Defaults to True.</p> <code>True</code> <code>isolate_transiting_planet</code> <code>bool</code> <p>Show the Keplerian curves for the transiting planet(s), if present in the model. Defaults to True.</p> <code>True</code> <code>include_jitters_in_points</code> <code>bool</code> <p>Include an extra error bar for each point which takes into account the jitter(s). This only works when ncurves=1. Defaults to False.</p> <code>False</code> <code>include_jitters_in_predict</code> <code>bool</code> <p>Include the jitters in the GP prediction (if model has a GP). This should almost always be True! Defaults to True.</p> <code>True</code> <code>full_plot</code> <code>bool</code> <p>If True (and ncurves=1), adds panels with the residuals from the given sample and their GLS periodogram. Defaults to False.</p> <code>False</code> <code>show_outliers</code> <code>bool</code> <p>Highlight the outliers (if likelihood is Student-t). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The figure with the plot</p>"},{"location":"docs/API/pykima/#kima.pykima.display.plot_random_samples_multiseries","title":"<code>plot_random_samples_multiseries(res, ncurves=50, samples=None, over=0.1, ntt=10000, show_vsys=False, isolate_known_object=True, include_jitters_in_points=False, include_jitters_in_predict=True, just_rvs=False, full_plot=False, highest_likelihood=False, **kwargs)</code>","text":"<p>Display the RV data together with curves from the posterior predictive. A total of <code>ncurves</code> random samples are chosen, and the Keplerian  curves are calculated covering 100 + <code>over</code>% of the data timespan. If the model has a GP component, the prediction is calculated using the GP hyperparameters for each of the random samples.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.Fixed","title":"<code>Fixed(value)</code>","text":"<p>Not a real distribution, just a parameter fixed at a given <code>value</code></p>"},{"location":"docs/API/pykima/#kima.pykima.utils.Fixed.logpdf","title":"<code>logpdf(x)</code>","text":"<p>Logarithm of the probability density function</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.Fixed.pdf","title":"<code>pdf(x)</code>","text":"<p>Probability density function: 1.0 if x==value, otherwise 0.0</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.Fixed.rvs","title":"<code>rvs()</code>","text":"<p>Random sample (always returns <code>value</code>)</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.ZeroDist","title":"<code>ZeroDist()</code>","text":"<p>A dummy probability distribution which always returns 0.0</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.apply_argsort","title":"<code>apply_argsort(arr1, arr2, axis=-1)</code>","text":"<p>Apply <code>arr1</code>.argsort() on <code>arr2</code>, along <code>axis</code>.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.chdir","title":"<code>chdir(dir, create=True)</code>","text":"<p>A simple context manager to switch directories temporarily</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.clipped_mean","title":"<code>clipped_mean(arr, min, max)</code>","text":"<p>Mean of <code>arr</code> between <code>min</code> and <code>max</code></p>"},{"location":"docs/API/pykima/#kima.pykima.utils.clipped_std","title":"<code>clipped_std(arr, min, max)</code>","text":"<p>Standard deviation of <code>arr</code> between <code>min</code> and <code>max</code></p>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_date_to_jd","title":"<code>date_date_to_jd(year, month, day)</code>","text":"<p>Convert a date (year, month, day) to Julian Day.</p> <p>Algorithm from 'Practical Astronomy with your Calculator or Spreadsheet',     4th ed., Duffet-Smith and Zwart, 2011.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year as integer. Years preceding 1 A.D. should be 0 or negative. The year before 1 A.D. is 0, 10 B.C. is year -9.</p> required <code>month</code> <code>int</code> <p>Month as integer, Jan = 1, Feb. = 2, etc.</p> required <code>day</code> <code>float</code> <p>Day, may contain fractional part.</p> required <p>Returns:</p> Name Type Description <code>jd</code> <code>float</code> <p>Julian Day</p> <p>Examples:</p> <p>Convert 6 a.m., February 17, 1985 to Julian Day</p> <pre><code>&gt;&gt;&gt; date_to_jd(1985, 2, 17.25)\n2446113.75\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_datetime_to_jd","title":"<code>date_datetime_to_jd(date)</code>","text":"<p>Convert a <code>datetime.datetime</code> object to Julian day.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>the date to be converted to Julian day</p> required <p>Returns:</p> Name Type Description <code>jd</code> <code>float</code> <p>Julian day</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = datetime.datetime(1985, 2, 17, 6)\n&gt;&gt;&gt; d\ndatetime.datetime(1985, 2, 17, 6, 0)\n&gt;&gt;&gt; jdutil.datetime_to_jd(d)\n2446113.75\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_days_to_hmsm","title":"<code>date_days_to_hmsm(days)</code>","text":"<p>Convert fractional days to hours, minutes, seconds, and microseconds. Precision beyond microseconds is rounded to the nearest microsecond.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>float</code> <p>A fractional number of days. Must be less than 1.</p> required <p>Returns:</p> Name Type Description <code>hour</code> <code>int</code> <p>Hour number</p> <code>min</code> <code>int</code> <p>Minute number</p> <code>sec</code> <code>int</code> <p>Second number</p> <code>micro</code> <code>int</code> <p>Microsecond number</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>days</code> is &gt;= 1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; days_to_hmsm(0.1)\n(2, 24, 0, 0)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_hmsm_to_days","title":"<code>date_hmsm_to_days(hour=0, min=0, sec=0, micro=0)</code>","text":"<p>Convert hours, minutes, seconds, and microseconds to fractional days.</p> <p>Parameters:</p> Name Type Description Default <code>hour</code> <code>int</code> <p>Hour number. Defaults to 0.</p> <code>0</code> <code>min</code> <code>int</code> <p>Minute number. Defaults to 0.</p> <code>0</code> <code>sec</code> <code>int</code> <p>Second number. Defaults to 0.</p> <code>0</code> <code>micro</code> <code>int</code> <p>Microsecond number. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>days</code> <code>float</code> <p>Fractional days</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hmsm_to_days(hour=6)\n0.25\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_jd_to_date","title":"<code>date_jd_to_date(jd)</code>","text":"<p>Convert Julian Day to date.</p> <p>Algorithm from 'Practical Astronomy with your Calculator or Spreadsheet',     4th ed., Duffet-Smith and Zwart, 2011.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian Day</p> required <p>Returns:</p> Name Type Description <code>year</code> <code>int</code> <p>Year as integer. Years preceding 1 A.D. should be 0 or negative. The year before 1 A.D. is 0, 10 B.C. is year -9.</p> <code>month</code> <code>int</code> <p>Month as integer, Jan = 1, Feb. = 2, etc.</p> <code>day</code> <code>float</code> <p>Day, may contain fractional part.</p> <p>Examples:</p> <p>Convert Julian Day 2446113.75 to year, month, and day.</p> <pre><code>&gt;&gt;&gt; jd_to_date(2446113.75)\n(1985, 2, 17.25)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_jd_to_mjd","title":"<code>date_jd_to_mjd(jd)</code>","text":"<p>Convert Julian Day to Modified Julian Day</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian Day</p> required <p>Returns     mjd (float): Modified Julian Day</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.date_mjd_to_jd","title":"<code>date_mjd_to_jd(mjd)</code>","text":"<p>Convert Modified Julian Day to Julian Day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Day</p> required <p>Returns     jd (float): Julian Day</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.distribution_rvs","title":"<code>distribution_rvs(dist, size=1)</code>","text":"<p>Generate random samples from a distribution.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>Distribution or rv_continuous</code> <p>The distribution to sample from</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code>"},{"location":"docs/API/pykima/#kima.pykima.utils.distribution_support","title":"<code>distribution_support(dist)</code>","text":"<p>Return the support of a distribution</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.find_constrained_invgamma","title":"<code>find_constrained_invgamma(low, upp, low_tail=0.01, upp_tail=0.01)</code>","text":"<p>Find the parameters of the inverse gamma distribution that is constrained between <code>low</code> and <code>upp</code> with tail probabilities <code>low_tail</code> and <code>upp_tail</code>.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.find_prior_limits","title":"<code>find_prior_limits(prior)</code>","text":"<p>Find lower and upper limits of a prior from the kima_model_setup.txt file.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.find_prior_parameters","title":"<code>find_prior_parameters(prior)</code>","text":"<p>Find parameters of a prior from the kima_model_setup.txt file.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_gaussian_prior_vsys","title":"<code>get_gaussian_prior_vsys(data, use_ptp=True, use_std=False, use_value=None)</code>","text":"<p>Get an informative Gaussian prior for the systemic velocity using the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RVData</code> <p>The RV dataset </p> required <code>use_ptp</code> <code>bool</code> <p>Width of the prior is the range of the data.</p> <code>True</code> <code>use_std</code> <code>bool</code> <p>Width of the prior is the standard deviation of the data.</p> <code>False</code> <code>use_value</code> <code>float</code> <p>Width of the prior is provided directly.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>prior</code> <code>Gaussian</code> <p>A Gaussian prior for the systemic velocity</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>use_ptp</code> and <code>use_std</code> are True</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_gaussian_priors_individual_offsets","title":"<code>get_gaussian_priors_individual_offsets(data, use_ptp=True, use_std=False, use_value=None)</code>","text":"<p>Get a informative Gaussian priors for the between-instrument offsets using the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RVData</code> <p>The RV dataset (must have multiple instruments)</p> required <code>use_ptp</code> <code>bool</code> <p>Width of the prior is the range of the data.</p> <code>True</code> <code>use_std</code> <code>bool</code> <p>Width of the prior is the standard deviation of the data.</p> <code>False</code> <code>use_value</code> <code>float</code> <p>Width of the prior is provided directly.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>prior</code> <code>Gaussian</code> <p>Gaussian priors appropriate for the between-instrument offsets</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If <code>data.multi</code> is False</li> <li>If both <code>use_ptp</code> and <code>use_std</code> are True</li> </ul>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_instrument_name","title":"<code>get_instrument_name(data_file)</code>","text":"<p>Try to find the instrument name from a filename</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_mean_longitude","title":"<code>get_mean_longitude(M0, w, fold=False, deg=False)</code>","text":"<p>Return the mean longitude \u03bb for a given mean anomaly M0 and longitude of periastron w (given by \u03bb = M0 + w).</p> <p>Parameters:</p> Name Type Description Default <code>M0</code> <code>float or ndarray</code> <p>Mean anomaly (M0=0 at periastron) [rad]</p> required <code>w</code> <code>float or ndarray</code> <p>Longitude of periastron [rad]</p> required <code>fold</code> <code>bool</code> <p>Fold the mean longitude into the range [-\u03c0, \u03c0) [default: False]</p> <code>False</code> <code>deg</code> <code>bool</code> <p>Return mean longitude in degrees [default: False]</p> <code>False</code> <p>Returns:</p> Name Type Description <code>\u03bb</code> <code>float or ndarray</code> <p>Mean longitude [rad or deg]</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_planet_teq","title":"<code>get_planet_teq(Tstar=5777, Rstar=1, a=1, A=0, f=1)</code>","text":"<p>Calculate the planet's equlibrium temperature</p> <p>Parameters:</p> Name Type Description Default <code>Tstar</code> <code>float</code> <p>Stellar effective temperature [K]. Defaults to 5777.</p> <code>5777</code> <code>Rstar</code> <code>float</code> <p>Stellar radius [Rsun]. Defaults to 1.0.</p> <code>1</code> <code>a</code> <code>float</code> <p>Planet semi-major axis [AU]. Defaults to 1.0.</p> <code>1</code> <code>A</code> <code>float</code> <p>Bond albedo. Defaults to 0.</p> <code>0</code> <code>f</code> <code>float</code> <p>Redistribution factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Teq</code> <code>float</code> <p>Planet equiolibrium temperature [K]</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_prior","title":"<code>get_prior(prior)</code>","text":"<p>Return a scipt.stats-like prior from a kima_model_setup.txt prior</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_star_name","title":"<code>get_star_name(data_file)</code>","text":"<p>Find star name (usually works for approx. standard filenames)</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.get_transit_probability","title":"<code>get_transit_probability(Rstar=1.0, a=1.0)</code>","text":"<p>Transit probability, simple. Eq 6.1 in Exoplanet Handbook Rstar: stellar radius [Rsun] a: semi-major axis [au]</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.hide_stdout","title":"<code>hide_stdout()</code>","text":"<p>A simple context manager to hide stdout temporarily</p> <p>Examples:</p> <pre><code>with hide_stdout():\n    print('hello') # no output\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.lighten_color","title":"<code>lighten_color(color, amount=0.5)</code>","text":"<p>Lightens the given <code>color</code> by multiplying (1-luminosity) by the given <code>amount</code>. Input can be a matplotlib color string, hex string, or RGB tuple.</p> <p>Examples:</p> <pre><code>lighten_color('g', 0.3)\nlighten_color('#F034A3', 0.6)\nlighten_color((.3, .55, .1), 0.5)\n</code></pre>"},{"location":"docs/API/pykima/#kima.pykima.utils.mean_anomaly_from_epoch","title":"<code>mean_anomaly_from_epoch(t, P, M0, epoch)</code>","text":"<p>Calculate mean anomaly for times t, given period P, mean anomaly at the epoch M0, and epoch.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>(float, ndarray)</code> <p>Times at which to calculate mean anomaly [days]</p> required <code>P</code> <code>float</code> <p>Orbital period [days]</p> required <code>M0</code> <code>float</code> <p>Mean anomaly at the epoch [rad]</p> required <code>epoch</code> <code>float</code> <p>Epoch [days]</p> required <p>Returns:</p> Name Type Description <code>M</code> <code>(float, ndarray)</code> <p>Mean anomaly [rad]</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.mean_anomaly_from_time_periastron","title":"<code>mean_anomaly_from_time_periastron(t, P, Tp, deg=False)</code>","text":"<p>Calculate mean anomaly for times t, given period P and time of periastron Tp.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>(float, ndarray)</code> <p>Times at which to calculate mean anomaly [days]</p> required <code>P</code> <code>float</code> <p>Orbital period [days]</p> required <code>Tp</code> <code>float</code> <p>Time of periastron [days]</p> required <code>deg</code> <code>bool</code> <p>Return mean anomaly in degrees [default: False]</p> <code>False</code> <p>Returns:</p> Name Type Description <code>M</code> <code>(float, ndarray)</code> <p>Mean anomaly [rad or deg]</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.percentile68_ranges","title":"<code>percentile68_ranges(a, min=None, max=None)</code>","text":"<p>Calculate the 16th and 84th percentiles of values in <code>a</code>, clipped between <code>min</code> and <code>max</code>.</p> <pre><code>     minus     median    plus     \n-------==========|==========------\n16%    |        68%        |    16%\n</code></pre> <p>Returns:</p> Name Type Description <code>median</code> <code>float</code> <p>Median value of <code>a</code>.</p> <code>plus</code> <code>float</code> <p>The 84th percentile minus the median.</p> <code>minus</code> <code>float</code> <p>The median minus the 16th percentile.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.percentile68_ranges_latex","title":"<code>percentile68_ranges_latex(a, min=None, max=None, collapse=True, include_dollar=True)</code>","text":"<p>Return a LaTeX-formatted string of the 68% range of values in <code>a</code>, clipped between <code>a</code> and <code>b</code>, in the form</p> <p>$ median ^{+ plus} _{- minus} $</p> <p>Parameters:</p> Name Type Description Default <code>collapse</code> <code>bool</code> <p>If True and plus=minus, return $ median \\pm plus $</p> <code>True</code> <code>include_dollar</code> <code>bool</code> <p>Whether to include dollar signs in the output, so it's a valid LaTeX math mode string</p> <code>True</code>"},{"location":"docs/API/pykima/#kima.pykima.utils.percentile_ranges","title":"<code>percentile_ranges(a, percentile=68, min=None, max=None)</code>","text":"<p>Calculate the given percentile range of values in <code>a</code>, clipped between <code>min</code> and <code>max</code>.</p> <p>Returns:</p> Name Type Description <code>median</code> <code>float</code> <p>Median value of <code>a</code>.</p> <code>plus</code> <code>float</code> <p>The 84th percentile minus the median.</p> <code>minus</code> <code>float</code> <p>The median minus the 16th percentile.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.read_datafile","title":"<code>read_datafile(datafile, skip)</code>","text":"<p>Read data from <code>datafile</code> for multiple instruments. Can be str, in which case the last column is assumed to contain an integer identifier of the instrument. Or list, in which case each element will be one different filename containing three columns each.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.read_datafile_rvfwhm","title":"<code>read_datafile_rvfwhm(datafile, skip)</code>","text":"<p>Read data from <code>datafile</code> for multiple instruments and RV-FWHM data.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.read_datafile_rvfwhmrhk","title":"<code>read_datafile_rvfwhmrhk(datafile, skip)</code>","text":"<p>Read data from <code>datafile</code> for multiple instruments and RV-FWHM-RHK data.</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.rms","title":"<code>rms(array)</code>","text":"<p>Root mean square of array</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.show_tips","title":"<code>show_tips()</code>","text":"<p>Show a few tips on how to use kima (but only sometimes)</p>"},{"location":"docs/API/pykima/#kima.pykima.utils.wrms","title":"<code>wrms(array, weights)</code>","text":"<p>Weighted root mean square of array, given weights</p>"},{"location":"docs/examples/","title":"Examples","text":"<p>kima provides several examples showing the analysis of standard datasets and some best practices.  Each example is implemented as a function which creates, and optionally runs, a given model. They can all be accessed through the <code>examples</code> module</p> <pre><code>from kima import examples\n</code></pre> <p>or directly</p> <pre><code>from kima.examples import multi_instrument\n</code></pre> <p>The following pages describe each example in some depth:</p> <ul> <li>_51Peg (note the <code>_</code> here, so the function can be a valid Python name)</li> <li>multi_instrument</li> <li>transiting_planet</li> </ul>"},{"location":"docs/examples/51Peg/","title":"51Peg","text":"<p>After installing kima, we'll go through one of the examples to start playing with the package. Let's find 51 Peg b!</p> <p>51 Peg b was the first exoplanet discovered around a solar-type star. The original paper, by Mayor &amp; Queloz (1995), used data from the ELODIE spectrograph. Here we will use another dataset, obtained with the Hamilton echelle spectrograph, situated in the Lick Observatory, in California (see Butler et al. 2006).</p> <p>Let's import the package and the example</p> In\u00a0[1]: Copied! <pre>import kima\nfrom kima.examples import _51Peg\n</pre> import kima from kima.examples import _51Peg Note <p>         The name <code>_51Peg</code> is a bit weird simply because Python variable names cannot start with a number. \ud83e\udd37     </p> <p>To take a quick look at the RV data, let's call the <code>_51Peg</code> function to just build the model, without running it:</p> In\u00a0[3]: Copied! <pre>model = _51Peg()\n\nmodel.data.plot();\n</pre> model = _51Peg()  model.data.plot(); <p>The data consist of 256 observations over almost 6 years, from October 1995 to October 2001. Our goal is to fit a Keplerian model to these radial-velocity observations. We will assumme the number of Keplerians to be free, with a uniform prior between 0 and 1, while all other priors take default values.</p> <p>We could run this model using the <code>kima.run()</code> function, but let's use the example directly (which runs 5000 steps by default):</p> In\u00a0[14]: Copied! <pre>model, res = _51Peg(run=True, load=True)\n</pre> model, res = _51Peg(run=True, load=True) <pre>log(Z) = -907.1448171972309\nInformation = 33.55284794677641 nats.\nEffective sample size = 534.6495957420269\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 534/534 [00:00&lt;00:00, 9019.79it/s]\n</pre> <p>We also loaded the results into the <code>res</code> variable, which we can use to look at some posterior distributions.</p> <p>For example, the posterior for the number of planet is quite clear, showing the significant detection of the planet:</p> In\u00a0[15]: Copied! <pre>res.plot_posterior_np();\n</pre> res.plot_posterior_np(); <pre>Np probability ratios:  []\n</pre> <p>The orbital period is also very well constrained:</p> In\u00a0[16]: Copied! <pre>res.plot_posterior_periods(show_prior=True);\n</pre> res.plot_posterior_periods(show_prior=True); Note <p>         The plot above also shows samples from the prior distribution,         which is log-uniform extending from 1 day to the timespan of the data.     </p> <p>We can also plot the histograms of the posteriors for the systemic velocity and for the instrumental jitter</p> In\u00a0[22]: Copied! <pre>res.hist_vsys();\nres.hist_jitter();\n</pre> res.hist_vsys(); res.hist_jitter(); <p>and the (more interesting) phase plot using the maximum likelihood solution</p> In\u00a0[19]: Copied! <pre>p = res.maximum_likelihood_sample()\n</pre> p = res.maximum_likelihood_sample() <pre>Sample with the highest likelihood value (logL = -869.59)\n-&gt; might not be representative of the full posterior distribution\n\njitter:\n  [2.8930339]\nnumber of planets:  1\norbital parameters:           P           K          M0           e           w \n                        4.23073    55.93763     5.07937     0.01090     0.61465\nvsys:  -1.78331207\n</pre> In\u00a0[20]: Copied! <pre>res.phase_plot(p);\n</pre> res.phase_plot(p); <p>So, kima tells us that a planet at a period of 4.23 days and an amplitude of ~56 m/s is the best model given the RV data. If it was 1995, we'd be going about changing the history of astronomy!</p>"},{"location":"docs/examples/jitter_rhk/","title":"Variable jitter","text":"<p>The RV dispersion is typically larger in more active stars.</p> <p>To account for this, D\u00edaz et al. (2016) proposed a model where the 'jitter' term depends on the value of the $\\log R'_{HK}$ indicator. Using the same notation as in the models page, this changes the default model in kima from</p> <p>$$ v_i \\sim \\mathcal{N} \\left( v_{sys} \\,,\\: j^2+\\sigma_i^2 \\right) $$</p> <p>to something like</p> <p>$$ v_i \\sim \\mathcal{N} \\left( v_{sys} \\,,\\: j^2 + (\\alpha_j \\cdot {\\rm RHK})^2 + \\sigma_i^2 \\right) $$</p> <p>where ${\\rm RHK}$ represents the values of $\\log R'_{HK}$ normalized to the range $[0-1]$.</p> Note <p>         The $\\log R'_{HK}$ values are normalized to $[0-1]$         by subtracting the minimun value and dividing by the peak-to-peak.         This means that the additional white noise at the minimum $\\log R'_{HK}$ value is zero.     </p> <p>The parameter $\\alpha_j$ is unknown and represents the slope of the dependence of the jitter with $\\log R'_{HK}$. We may assume that $\\alpha_j&gt;0$ always. This model is implemented in RVmodel with the <code>jitter_propto_indicator</code> setting.</p> <p>Let's see an example.</p> <p>First, we get some standard imports out of the way</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport kima\nfrom kima import keplerian\n</pre> import numpy as np import matplotlib.pyplot as plt import kima from kima import keplerian <p>We'll generate a simple RV dataset that contains only noise. At the same time, we also generate fake $\\log R'_{HK}$ values which first increase slightly and then decrease. This simulates the variation that could be observed due to a stellar magnetic cycle.</p> In\u00a0[4]: Copied! <pre>def create_data(multiple_instruments=False):\n    np.random.seed(43)  # to be reproducible\n\n    # random times over a short timespan\n    t = np.sort(np.random.uniform(0, 100, 87))\n\n    # RVs with only white noise and associated uncertainties\n    rv = np.random.normal(loc=-3, scale=0.01, size=t.size)\n    err_rv = np.random.uniform(0.1, 0.4, t.size)\n\n    # simulate log R'HK (using a Keplerian function just for convenience)\n    rhk = -4.9 + np.array(keplerian(t, 300, 0.1, 0.5, 0.0, 0, 60))\n    rhk += np.random.normal(loc=0.0, scale=3e-3, size=t.size)\n    err_rhk = np.random.uniform(4e-3, 6e-3, t.size)\n\n    # normalize to range [0, 1]\n    norm_rhk = (rhk - rhk.min()) / np.ptp(rhk)\n\n    # to simulate multiple instruments, add an RV offset to some points\n    mask = None\n    if multiple_instruments:\n        mask = np.arange(t.size) &gt; 2 *t.size // 3\n        rv[mask] += 2.5\n\n    # !!! add jitter proportional to (normalized) log R'HK !!!\n    alpha = 2.1\n    rv += np.random.normal(loc=0, scale=alpha * norm_rhk, size=t.size)\n\n    # save the data in text files\n    kw = dict(fmt='%10.5f', header='t rv err_rv rhk err_rhk')\n    if multiple_instruments:\n        D1 = np.c_[\n            t[~mask], rv[~mask], err_rv[~mask], rhk[~mask], err_rhk[~mask]\n        ]\n        D2 = np.c_[\n            t[mask], rv[mask], err_rv[mask], rhk[mask], err_rhk[mask]\n        ]\n        np.savetxt('data1.txt', D1, **kw)\n        np.savetxt('data2.txt', D2, **kw)\n    else:\n        D = np.c_[t, rv, err_rv, rhk, err_rhk]\n        np.savetxt('data.txt', D, **kw)\n    \n    return t, rv, err_rv, rhk, err_rhk, mask\n</pre> def create_data(multiple_instruments=False):     np.random.seed(43)  # to be reproducible      # random times over a short timespan     t = np.sort(np.random.uniform(0, 100, 87))      # RVs with only white noise and associated uncertainties     rv = np.random.normal(loc=-3, scale=0.01, size=t.size)     err_rv = np.random.uniform(0.1, 0.4, t.size)      # simulate log R'HK (using a Keplerian function just for convenience)     rhk = -4.9 + np.array(keplerian(t, 300, 0.1, 0.5, 0.0, 0, 60))     rhk += np.random.normal(loc=0.0, scale=3e-3, size=t.size)     err_rhk = np.random.uniform(4e-3, 6e-3, t.size)      # normalize to range [0, 1]     norm_rhk = (rhk - rhk.min()) / np.ptp(rhk)      # to simulate multiple instruments, add an RV offset to some points     mask = None     if multiple_instruments:         mask = np.arange(t.size) &gt; 2 *t.size // 3         rv[mask] += 2.5      # !!! add jitter proportional to (normalized) log R'HK !!!     alpha = 2.1     rv += np.random.normal(loc=0, scale=alpha * norm_rhk, size=t.size)      # save the data in text files     kw = dict(fmt='%10.5f', header='t rv err_rv rhk err_rhk')     if multiple_instruments:         D1 = np.c_[             t[~mask], rv[~mask], err_rv[~mask], rhk[~mask], err_rhk[~mask]         ]         D2 = np.c_[             t[mask], rv[mask], err_rv[mask], rhk[mask], err_rhk[mask]         ]         np.savetxt('data1.txt', D1, **kw)         np.savetxt('data2.txt', D2, **kw)     else:         D = np.c_[t, rv, err_rv, rhk, err_rhk]         np.savetxt('data.txt', D, **kw)          return t, rv, err_rv, rhk, err_rhk, mask <p>Let's call the function and visualize the data</p> In\u00a0[6]: Copied! <pre>t, rv, err_rv, rhk, err_rhk, mask = create_data()\n</pre> t, rv, err_rv, rhk, err_rhk, mask = create_data() In\u00a0[7]: Copied! <pre>fig, axs = plt.subplots(2, 1, constrained_layout=True)\naxs[0].errorbar(t, rv, err_rv, fmt='o', ms=3)\naxs[1].errorbar(t, rhk, err_rhk, fmt='o', ms=3)\naxs[0].set(xlabel='Time [days]', ylabel='RV [m/s]');\naxs[1].set(xlabel='Time [days]', ylabel=r\"$\\log R'_{HK}$\");\n</pre> fig, axs = plt.subplots(2, 1, constrained_layout=True) axs[0].errorbar(t, rv, err_rv, fmt='o', ms=3) axs[1].errorbar(t, rhk, err_rhk, fmt='o', ms=3) axs[0].set(xlabel='Time [days]', ylabel='RV [m/s]'); axs[1].set(xlabel='Time [days]', ylabel=r\"$\\log R'_{HK}$\"); <p>As we wanted, the variance of the RVs depends (linearly) on the $\\log R'_{HK}$. For the case of multiple instruments, the data looks very similar, except for the added RV offset:</p> In\u00a0[8]: Copied! <pre>t, rv, err_rv, rhk, err_rhk, mask = create_data(multiple_instruments=True)\n</pre> t, rv, err_rv, rhk, err_rhk, mask = create_data(multiple_instruments=True) In\u00a0[9]: Copied! <pre>fig, axs = plt.subplots(2, 1, constrained_layout=True)\naxs[0].errorbar(t[~mask], rv[~mask], err_rv[~mask], fmt='o', ms=3)\naxs[0].errorbar(t[mask], rv[mask], err_rv[mask], fmt='o', ms=3)\naxs[1].errorbar(t[~mask], rhk[~mask], err_rhk[~mask], fmt='o', ms=3)\naxs[1].errorbar(t[mask], rhk[mask], err_rhk[mask], fmt='o', ms=3)\naxs[0].set(xlabel='Time [days]', ylabel='RV [m/s]');\naxs[1].set(xlabel='Time [days]', ylabel=r\"$\\log R'_{HK}$\");\n</pre> fig, axs = plt.subplots(2, 1, constrained_layout=True) axs[0].errorbar(t[~mask], rv[~mask], err_rv[~mask], fmt='o', ms=3) axs[0].errorbar(t[mask], rv[mask], err_rv[mask], fmt='o', ms=3) axs[1].errorbar(t[~mask], rhk[~mask], err_rhk[~mask], fmt='o', ms=3) axs[1].errorbar(t[mask], rhk[mask], err_rhk[mask], fmt='o', ms=3) axs[0].set(xlabel='Time [days]', ylabel='RV [m/s]'); axs[1].set(xlabel='Time [days]', ylabel=r\"$\\log R'_{HK}$\"); Note <p>         With this very simple simulation, we are trying to reproduce the observed data of active stars.         For example, compare the above with Fig. 9 from         D\u00edaz et al.(2016),         showing HARPS data for HD40307:     </p> <p>Let's now fit these data, assuming the usual model with a fixed jitter value</p> In\u00a0[10]: Copied! <pre>from kima import RVData, RVmodel, distributions\n\ndata = RVData('data.txt')\nmodel = RVmodel(fix=True, npmax=0, data=data)\n</pre> from kima import RVData, RVmodel, distributions  data = RVData('data.txt') model = RVmodel(fix=True, npmax=0, data=data) <p>Run the model for a few thousand steps</p> In\u00a0[11]: Copied! <pre>%%time\nkima.run(model, steps=5000, num_threads=4)\n</pre> %%time kima.run(model, steps=5000, num_threads=4) <pre>CPU times: total: 4.95 s\nWall time: 3.63 s\n</pre> <p>and load the results</p> In\u00a0[12]: Copied! <pre>res1 = kima.load_results(model)\n</pre> res1 = kima.load_results(model) <pre>log(Z) = -158.41\nInformation = 5.34 nats\nBMD = 2.06\nEffective sample size = 491.0\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 491/491 [00:00&lt;00:00, 21895.27it/s]\n</pre> In\u00a0[13]: Copied! <pre>res1.plot_random_samples();\n</pre> res1.plot_random_samples(); In\u00a0[14]: Copied! <pre>res1.hist_jitter();\n</pre> res1.hist_jitter(); <p>Now we run a model where the jitter is proportional to it.</p> In\u00a0[15]: Copied! <pre>data = RVData('data.txt', indicators=['rhk', 'err_rhk'])\nmodel = RVmodel(fix=True, npmax=0, data=data)\nmodel.jitter_propto_indicator = True\n</pre> data = RVData('data.txt', indicators=['rhk', 'err_rhk']) model = RVmodel(fix=True, npmax=0, data=data) model.jitter_propto_indicator = True In\u00a0[16]: Copied! <pre>%%time\nkima.run(model, steps=5000, num_threads=4)\n</pre> %%time kima.run(model, steps=5000, num_threads=4) <pre>CPU times: total: 6.53 s\nWall time: 3.84 s\n</pre> In\u00a0[17]: Copied! <pre>res2 = kima.load_results(model)\n</pre> res2 = kima.load_results(model) <pre>log(Z) = -126.71\nInformation = 10.09 nats\nBMD = 3.03\nEffective sample size = 623.7\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 623/623 [00:00&lt;00:00, 27750.59it/s]\n</pre> In\u00a0[18]: Copied! <pre>res2.plot_random_samples();\n</pre> res2.plot_random_samples(); In\u00a0[19]: Copied! <pre>res2.hist_jitter();\n</pre> res2.hist_jitter(); <p>Doing model comparison it looks like the second model is indeed a much better description of the data:</p> In\u00a0[27]: Copied! <pre>print(f'lnZ model 1: {res1.evidence}')\nprint(f'lnZ model 2: {res2.evidence}')\n</pre> print(f'lnZ model 1: {res1.evidence}') print(f'lnZ model 2: {res2.evidence}') <pre>lnZ model 1: -158.4087102649185\nlnZ model 2: -126.71029077297631\n</pre> TODO"},{"location":"docs/examples/jitter_rhk/#variable-jitter","title":"Variable jitter\u00b6","text":""},{"location":"docs/examples/jitter_rhk/#simulating-a-dataset","title":"Simulating a dataset\u00b6","text":""},{"location":"docs/examples/jitter_rhk/#a-model-with-fixed-jitter","title":"A model with fixed jitter\u00b6","text":""},{"location":"docs/examples/jitter_rhk/#jitter-proportional-to-log-r_hk","title":"Jitter proportional to $\\log R'_{HK}$\u00b6","text":""},{"location":"docs/examples/jitter_rhk/#harps-data-for-hd40307","title":"HARPS data for HD40307\u00b6","text":""},{"location":"docs/examples/multi_instrument/","title":"Multiple instruments","text":"<p>It is quite typical to have RV observations from more than one instrument. These data should be analysed together for the detection of planets.</p> Note <p> <ul> <li>             Considering RVs from multiple instruments means adding new offset parameters to the model.             By default, all these parameters share the same prior, but we'll see below how to change this.         </li> <li>             The same applies to the additional white noise (jitter).             One jitter parameter is added per instrument, all sharing the same prior.         </li> </ul> </p> New <p>     Newer versions of kima now allow for a stellar jitter parameter      which is shared between all the instruments. By default, this parameter is fixed to zero      to recover the old behaviour.     </p> <p>First of all, let's import the package</p> In\u00a0[1]: Copied! <pre>import kima\n</pre> import kima <p>Each of the datasets can be imported like this</p> In\u00a0[2]: Copied! <pre>from kima.examples.multi_instruments import HD106252_ELODIE\n</pre> from kima.examples.multi_instruments import HD106252_ELODIE <p>and a simple visualisation of the RVs is provided by the <code>plot</code> method</p> In\u00a0[3]: Copied! <pre>HD106252_ELODIE.plot();\n</pre> HD106252_ELODIE.plot(); <p>The combined data is also readily available</p> In\u00a0[4]: Copied! <pre>from kima.examples.multi_instruments import HD106252_combined\n\nHD106252_combined.plot();\n</pre> from kima.examples.multi_instruments import HD106252_combined  HD106252_combined.plot(); <p>Note the clear offset between ELODIE data (in blue above) and the other datasets. The average RV has been subtracted from the HET, HJS, and Lick data, but not from ELODIE. This slightly convoluted situation is ideal to demonstrate how kima deals with multiple instruments, especially with the default priors.</p> <p>We can now use one of the available models to analyse this dataset. We can either create the model</p> In\u00a0[5]: Copied! <pre>from kima import RVmodel\n\nmodel = RVmodel(fix=False, npmax=1, data=HD106252_combined)\n</pre> from kima import RVmodel  model = RVmodel(fix=False, npmax=1, data=HD106252_combined) <p>or import the <code>multi_instruments</code> function from the examples, which does the same thing (but can also run the model directly)</p> In\u00a0[6]: Copied! <pre>from kima.examples import multi_instruments\n\nmodel = multi_instruments(run=False)\n</pre> from kima.examples import multi_instruments  model = multi_instruments(run=False) <p>Notice how we set the number of planets to be free, implicitly assigning to it a uniform prior between 0 and 1 (by setting <code>npmax=1</code>).</p> <p>This is all that is necessary to setup the data and model, and we are now ready to run the analysis. Notice that we didn't explicitly assign any priors (except for the number of planets). This means kima will use all the default priors.</p> <p>Let's run the model for a few thousand steps and load the results</p> In\u00a0[7]: Copied! <pre>model, res = multi_instruments(run=True, load=True, steps=30_000)\n</pre> model, res = multi_instruments(run=True, load=True, steps=30_000) <pre>log(Z) = -498.67164265769134\nInformation = 67.6310091586351 nats.\nEffective sample size = 2984.7236142899683\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2984/2984 [00:00&lt;00:00, 8048.22it/s]\n</pre> <p>Did we find HD106252 b?</p> In\u00a0[8]: Copied! <pre>res.plot_posterior_np();\n</pre> res.plot_posterior_np(); <pre>Np probability ratios:  []\n</pre> <p>Yes! In fact, even though the $N_p$ parameter was free, all the samples have $N_p=1$ because the posterior probability is so much higher than for $N_p=0$. So we're pretty sure about this detection. How does the fit look?</p> In\u00a0[9]: Copied! <pre>res.plot_random_samples();\n</pre> res.plot_random_samples(); <p>The <code>plot_random_samples</code> function just shows the Keplerian curves from a few random posterior samples, together with the data. Note that the RV offsets for each instrument are not subtracted from the data. This is on purpose: since we're showing several posterior samples (50 by default), there are actually several values for the offsets. Zooming in on one particular dataset helps (note the several blue curves):</p> In\u00a0[10]: Copied! <pre>fig = res.plot_random_samples();\nfig.axes[0].set_ylim(9600, 10200);\n</pre> fig = res.plot_random_samples(); fig.axes[0].set_ylim(9600, 10200); <p>Looking at the posterior for the orbital period, semi-amplitude, and eccentricity of the planet clearly shows that the default priors are a bit too wide</p> In\u00a0[11]: Copied! <pre>res.plot_posterior_PKE(show_prior=True);\n</pre> res.plot_posterior_PKE(show_prior=True); <p>The situation is similar for the systemic velocity and for the RV offsets, as evidenced in the plots below, where we might not even see the posterior!</p> In\u00a0[12]: Copied! <pre>res.hist_vsys(show_prior=True)\n</pre> res.hist_vsys(show_prior=True) Out[12]: <pre>[&lt;Figure size 640x480 with 1 Axes&gt;, &lt;Figure size 1100x500 with 3 Axes&gt;]</pre> <p>but they're there:</p> In\u00a0[13]: Copied! <pre>res.hist_vsys();\n</pre> res.hist_vsys(); <p>What we see here is that kima tries very hard to have default priors which will be appropriate for every RV dataset. However, this does sometimes mean that the priors are way too wide, which might hurt the performance of the sampler.</p> <p>These issues can be easily solved by setting slightly more informative priors for the RV offsets and some of the orbital parameters. We'll use a couple of helper functions available in <code>pykima.utils</code> to assign appropriate Gaussian priors.</p> In\u00a0[14]: Copied! <pre>from kima.pykima.utils import (get_gaussian_prior_vsys, \n                               get_gaussian_priors_individual_offsets)\n</pre> from kima.pykima.utils import (get_gaussian_prior_vsys,                                 get_gaussian_priors_individual_offsets) In\u00a0[15]: Copied! <pre>model.Cprior = get_gaussian_prior_vsys(model.data, use_std=True)\nmodel.Cprior\n</pre> model.Cprior = get_gaussian_prior_vsys(model.data, use_std=True) model.Cprior Out[15]: <pre>Gaussian(62; 102.095)</pre> In\u00a0[16]: Copied! <pre>model.individual_offset_prior = get_gaussian_priors_individual_offsets(model.data, use_std=True)\nmodel.individual_offset_prior\n</pre> model.individual_offset_prior = get_gaussian_priors_individual_offsets(model.data, use_std=True) model.individual_offset_prior Out[16]: <pre>[Gaussian(15518.5; 96.3933),\n Gaussian(-71.9; 59.0117),\n Gaussian(-65.4; 61.2813)]</pre> <p>and also set a narrower prior for the semi-amplitude</p> In\u00a0[17]: Copied! <pre>model.conditional.Kprior = kima.distributions.Uniform(0, 500)\n</pre> model.conditional.Kprior = kima.distributions.Uniform(0, 500) <p>Let's run the model again using the new priors</p> In\u00a0[18]: Copied! <pre>kima.run(model, steps=30_000, num_threads=4)\n</pre> kima.run(model, steps=30_000, num_threads=4) In\u00a0[21]: Copied! <pre>res = kima.load_results()\n</pre> res = kima.load_results() <pre>log(Z) = -470.77601559796693\nInformation = 41.027161549708126 nats.\nEffective sample size = 3207.732713141128\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3207/3207 [00:00&lt;00:00, 11334.12it/s]\n</pre> <p>The priors for the systemic velocity and RV offsets are still relatively wide but much more comparable to the posteriors</p> In\u00a0[26]: Copied! <pre>res.hist_vsys(show_prior=True);\n</pre> res.hist_vsys(show_prior=True); <p>and for the orbital parameters</p> In\u00a0[23]: Copied! <pre>res.plot_posterior_PKE(show_prior=True);\n</pre> res.plot_posterior_PKE(show_prior=True); <p>In any case, the orbital parameters of HD106252 b are well recovered. The maximum likelihood solution provides an excellent fit to the data.</p> In\u00a0[24]: Copied! <pre>p = res.maximum_likelihood_sample()\nres.phase_plot(p);\n</pre> p = res.maximum_likelihood_sample() res.phase_plot(p); <pre>Sample with the highest likelihood value (logL = -422.84)\n-&gt; might not be representative of the full posterior distribution\n\njitter:\n[ 0.          6.40600629  0.92606019 10.59487361  3.81708227]\nnumber of planets:  1\norbital parameters:           P           K          M0           e           \u03c9 \n                     1532.14695   140.23845     0.72411     0.48398     5.10110\ninstrument offsets:  (relative to Lick) \n                     ELODIE                HET                   HJS                  \n                     15519.108             -98.130               -84.104              \nvsys:  6.95947983\n0 1 1\n</pre> Warning <p>     In this example, we used some properties of the data to assign priors for a few parameters.     Some Bayesians might not agree with this and, in general, they would be right.      However, note in the figures above for the original analysis how there's just no posterior      mass across very very wide regions of the prior. Upon realizing this, we tried to come up      with more informative priors. That means that, in essence, we just performed a prior      sensitivity analysis, and concluded that the posterior estimates for the parameters were consistent.     </p> <p>     Note also that this is very different from setting a prior for the orbital period     based on a periodogram analysis, for example, which is almost never justified.     </p>"},{"location":"docs/examples/multi_instrument/#multiple-instruments","title":"Multiple instruments\u00b6","text":""},{"location":"docs/examples/multi_instrument/#detecting-the-planet-around-hd106252","title":"Detecting the planet around HD106252\u00b6","text":"<p>First announced by Fischer et al. (2002), the giant planet orbiting HD106252 has been detected with a number of different instruments (Perrier et al. 2003, Butler et al. 2006, Wittenmyer et al.2009). In this example, we look at data from ELODIE, HET, HJS, and Lick.</p>"},{"location":"docs/examples/transiting_planet/","title":"(Mono-)Transiting planets","text":"<p>The way in which the Keplerian function is parameterized in kima is most useful for RV detection, but can in some cases become a bottleneck.</p> <p>One such case is when a planet is observed to transit only one or two times, the so-called mono-transits or duo-transits. Here, the orbital period is uncertain but the time of transit is known relatively well, and so the standard parameterization in ($ P, K, e, M_0, \\omega $), which is used for the <code>known_object</code> as well, is not ideal.</p> Note <p>         The (old) work-around of using the <code>Gaussian_from_Tc</code> prior for \\(M_0\\)         will not help in cases like this.     </p> <p>To allow for this corner case, a new <code>transiting_planet</code> mode has been added. This is much alike the <code>known_object</code>, except that the Keplerian is parameterized directly in terms of ($P, K, e, \\omega, T_c$). In this way, independent priors can be assigned to these parameters.</p> <p>Let's see an example.</p> <p>First, we get some standard imports out of the way</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport kima\n</pre> import numpy as np import matplotlib.pyplot as plt import kima <p>We'll create a function to generate a simple RV dataset containing a planet. We define the time of periastron and then calculate the time of conjunction from it. To make things interesting, we remove a few data points so that the orbit is slightly harder to constrain.</p> In\u00a0[2]: Copied! <pre>def create_data():\n    np.random.seed(43) # to be reproducible\n\n    # random times and uncertainties\n    t = np.sort(np.random.uniform(0, 100, 57))\n    err = np.random.uniform(0.1, 0.3, t.size)\n\n    # define orbital parameters\n    P, K, e, w = 30, 2, 0.6, 0.1\n    # define time of periastron\n    Tp = 15\n    # use the time of first observation as \"epoch\"\n    M0_epoch = t[0]\n    # mean anomaly at the epoch\n    M0 = 2 * np.pi * (M0_epoch - Tp) / P\n\n    # calculate the time of conjunction\n    f = np.pi/2 - w\n    E = 2 * np.arctan(np.tan(f/2) * np.sqrt((1-e)/(1+e)))\n    Tc = Tp + P/(2*np.pi) * (E - e*np.sin(E))\n\n    # simulate a Keplerian function\n    v = kima.keplerian(t, P, K, e, w, M0, M0_epoch)\n    # and add some small Gaussian noise\n    v += np.random.normal(loc=0.0, scale=0.05, size=t.size)\n\n    # remove some points to make things interesting\n    t = t[v &lt; 1]\n    err = err[v &lt; 1]\n    v = v[v &lt; 1]\n\n    return (t, v, err), P, K, Tp, e, w, M0, M0_epoch, Tc\n</pre> def create_data():     np.random.seed(43) # to be reproducible      # random times and uncertainties     t = np.sort(np.random.uniform(0, 100, 57))     err = np.random.uniform(0.1, 0.3, t.size)      # define orbital parameters     P, K, e, w = 30, 2, 0.6, 0.1     # define time of periastron     Tp = 15     # use the time of first observation as \"epoch\"     M0_epoch = t[0]     # mean anomaly at the epoch     M0 = 2 * np.pi * (M0_epoch - Tp) / P      # calculate the time of conjunction     f = np.pi/2 - w     E = 2 * np.arctan(np.tan(f/2) * np.sqrt((1-e)/(1+e)))     Tc = Tp + P/(2*np.pi) * (E - e*np.sin(E))      # simulate a Keplerian function     v = kima.keplerian(t, P, K, e, w, M0, M0_epoch)     # and add some small Gaussian noise     v += np.random.normal(loc=0.0, scale=0.05, size=t.size)      # remove some points to make things interesting     t = t[v &lt; 1]     err = err[v &lt; 1]     v = v[v &lt; 1]      return (t, v, err), P, K, Tp, e, w, M0, M0_epoch, Tc In\u00a0[3]: Copied! <pre>(t, v, err), P, K, Tp, e, w, M0, M0_epoch, Tc = create_data()\n</pre> (t, v, err), P, K, Tp, e, w, M0, M0_epoch, Tc = create_data() <p>Let's plot the data together with the true Keplerian model</p> In\u00a0[4]: Copied! <pre>tt = np.linspace(t[0], t[-1], 1000)\nvv = kima.keplerian(tt, P, K, e, w, M0, M0_epoch)\n\nfig, ax = plt.subplots()\nax.errorbar(t, v, err, fmt='o', label='data')\nax.plot(tt, vv, color='g', label='true Keplerian')\nax.legend()\nax.set(xlabel='Time [days]', ylabel='RV [m/s]');\n</pre> tt = np.linspace(t[0], t[-1], 1000) vv = kima.keplerian(tt, P, K, e, w, M0, M0_epoch)  fig, ax = plt.subplots() ax.errorbar(t, v, err, fmt='o', label='data') ax.plot(tt, vv, color='g', label='true Keplerian') ax.legend() ax.set(xlabel='Time [days]', ylabel='RV [m/s]'); <p>Let's now fit these data, assuming only that we know there is one Keplerian signal</p> In\u00a0[5]: Copied! <pre>from kima import RVData, RVmodel, distributions\n\ndata = RVData(t, v, err)\nmodel = RVmodel(fix=True, npmax=1, data=data)\n\n# since we didn't simulate any jitter, let's just assume it's zero\nmodel.Jprior = distributions.Fixed(0.0)\n</pre> from kima import RVData, RVmodel, distributions  data = RVData(t, v, err) model = RVmodel(fix=True, npmax=1, data=data)  # since we didn't simulate any jitter, let's just assume it's zero model.Jprior = distributions.Fixed(0.0) <p>Run the model for a few thousand steps</p> In\u00a0[6]: Copied! <pre>kima.run(model, steps=30_000, num_threads=4)\n</pre> kima.run(model, steps=30_000, num_threads=4) <p>and now load the results</p> In\u00a0[6]: Copied! <pre>res1 = kima.load_results(model)\n</pre> res1 = kima.load_results(model) <pre>log(Z) = 13.876939900974554\nInformation = 16.97202651128454 nats.\nEffective sample size = 4131.119355475683\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4131/4131 [00:00&lt;00:00, 24176.37it/s]\n</pre> <p>Plotting a few posterior samples together with the data already shows that we didn't recover the true Keplerian signal very well</p> In\u00a0[7]: Copied! <pre>fig = res1.plot_random_samples(legend=False)\nfig.axes[0].plot(tt, vv, color='g');\n</pre> fig = res1.plot_random_samples(legend=False) fig.axes[0].plot(tt, vv, color='g'); <p>and indeed the posteriors for the orbital parameters show that, while the period was recovered, the semi-amplitude and eccentricity are a bit off from the true values</p> In\u00a0[10]: Copied! <pre>res1.corner_planet_parameters(true_values=[P, K, M0+2*np.pi, e, w]);\n</pre> res1.corner_planet_parameters(true_values=[P, K, M0+2*np.pi, e, w]); <p>In our convoluted example, we do have information about the time of conjunction $T_c$. If we assume we don't know the orbital period, then we are basically in a similar situation to a mono-transit or a duo-transit.</p> <p>Let's fit the data again with a model that uses one transiting planet, allowing us to assign a prior to $T_c$ directly.</p> In\u00a0[12]: Copied! <pre>#same as before\ndata = RVData(t, v, err)\n\n# no 'normal' Keplerians, as we'll use a 'transiting planet'\nmodel = RVmodel(fix=True, npmax=0, data=data)\n\n# same as before\nmodel.Jprior = distributions.Fixed(0.0)\n\n# assume there is one planet\nmodel.set_transiting_planet(1)\n# set standard priors (same as before)\nmodel.TR_Pprior = [distributions.LogUniform(1.0, data.get_timespan())]\nmodel.TR_Kprior = [distributions.Uniform(0.0, 5*data.get_RV_span())]\nmodel.TR_eprior = [distributions.Uniform(0, 1)]\nmodel.TR_wprior = [distributions.UniformAngle()]\n# but for Tc, use the known value\nmodel.TR_Tcprior = [distributions.Gaussian(Tc, 1e-3)]\n</pre> #same as before data = RVData(t, v, err)  # no 'normal' Keplerians, as we'll use a 'transiting planet' model = RVmodel(fix=True, npmax=0, data=data)  # same as before model.Jprior = distributions.Fixed(0.0)  # assume there is one planet model.set_transiting_planet(1) # set standard priors (same as before) model.TR_Pprior = [distributions.LogUniform(1.0, data.get_timespan())] model.TR_Kprior = [distributions.Uniform(0.0, 5*data.get_RV_span())] model.TR_eprior = [distributions.Uniform(0, 1)] model.TR_wprior = [distributions.UniformAngle()] # but for Tc, use the known value model.TR_Tcprior = [distributions.Gaussian(Tc, 1e-3)] <p>Let's run the model again</p> In\u00a0[13]: Copied! <pre>kima.run(model, steps=30_000, num_threads=4)\n</pre> kima.run(model, steps=30_000, num_threads=4) In\u00a0[14]: Copied! <pre>res2 = kima.load_results(model)\n</pre> res2 = kima.load_results(model) <pre>log(Z) = 15.620712644328114\nInformation = 16.053040966880445 nats.\nEffective sample size = 4121.815081323306\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4121/4121 [00:00&lt;00:00, 32222.62it/s]\n</pre> <p>and now the true Keplerian signal is much better recovered</p> In\u00a0[15]: Copied! <pre>fig = res2.plot_random_samples(legend=False)\nfig.axes[0].plot(tt, vv, color='g');\n</pre> fig = res2.plot_random_samples(legend=False) fig.axes[0].plot(tt, vv, color='g'); <p>The posteriors for the orbital parameters (of the transiting planet) show that just by setting a prior on $T_c$, we are now able to recover the true values of the semi-amplitude and eccentricity</p> In\u00a0[18]: Copied! <pre>res2.corner_planet_parameters(true_values=[P, K, Tc, e, w],\n                              include_transiting_planet=True);\n</pre> res2.corner_planet_parameters(true_values=[P, K, Tc, e, w],                               include_transiting_planet=True); <pre>WARNING:root:Too few points to create valid contours\n</pre> In\u00a0[19]: Copied! <pre>_, axs = plt.subplots(1, 4, constrained_layout=True, figsize=(10, 4))\n\naxs[0].axvline(P, color='k', lw=2, label='true value')\naxs[1].axvline(K, color='k', lw=2, label='true value')\naxs[2].axvline(e, color='k', lw=2, label='true value')\n\nkw = dict(density=True, histtype='step')\n\nfor r in [res1, res2]:\n    if hasattr(r, 'TR') and r.TR:\n        axs[0].hist(r.TRpars[:, 0], **kw, label='transiting planet')\n        axs[1].hist(r.TRpars[:, 1], **kw, label='transiting planet')\n        axs[2].hist(r.TRpars[:, 3], **kw, label='transiting planet')\n    else:\n        axs[0].hist(r.posteriors.P.ravel(), **kw, label='normal Keplerian')\n        axs[1].hist(r.posteriors.K.ravel(), **kw, label='normal Keplerian')\n        axs[2].hist(r.posteriors.e.ravel(), **kw, label='normal Keplerian')\n\naxs[0].set(xlabel='P [days]', ylabel='posterior')\naxs[1].set(xlabel='K [m/s]', ylabel='posterior')\naxs[2].set(xlabel='e', ylabel='posterior')\naxs[3].legend(*axs[0].get_legend_handles_labels())\naxs[3].axis('off');\n</pre> _, axs = plt.subplots(1, 4, constrained_layout=True, figsize=(10, 4))  axs[0].axvline(P, color='k', lw=2, label='true value') axs[1].axvline(K, color='k', lw=2, label='true value') axs[2].axvline(e, color='k', lw=2, label='true value')  kw = dict(density=True, histtype='step')  for r in [res1, res2]:     if hasattr(r, 'TR') and r.TR:         axs[0].hist(r.TRpars[:, 0], **kw, label='transiting planet')         axs[1].hist(r.TRpars[:, 1], **kw, label='transiting planet')         axs[2].hist(r.TRpars[:, 3], **kw, label='transiting planet')     else:         axs[0].hist(r.posteriors.P.ravel(), **kw, label='normal Keplerian')         axs[1].hist(r.posteriors.K.ravel(), **kw, label='normal Keplerian')         axs[2].hist(r.posteriors.e.ravel(), **kw, label='normal Keplerian')  axs[0].set(xlabel='P [days]', ylabel='posterior') axs[1].set(xlabel='K [m/s]', ylabel='posterior') axs[2].set(xlabel='e', ylabel='posterior') axs[3].legend(*axs[0].get_legend_handles_labels()) axs[3].axis('off');"},{"location":"docs/examples/transiting_planet/#mono-transiting-planets","title":"(Mono-)Transiting planets\u00b6","text":""},{"location":"docs/examples/transiting_planet/#simulating-a-dataset","title":"Simulating a dataset\u00b6","text":""},{"location":"docs/examples/transiting_planet/#a-simple-fit","title":"A simple fit\u00b6","text":""},{"location":"docs/examples/transiting_planet/#assuming-t_c-is-known","title":"Assuming $T_c$ is known\u00b6","text":""}]}